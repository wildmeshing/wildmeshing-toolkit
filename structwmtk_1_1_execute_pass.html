<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wildmeshing Toolkit: wmtk::ExecutePass&lt; AppMesh, policy &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wildmeshing Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>wmtk</b></li><li class="navelem"><a class="el" href="structwmtk_1_1_execute_pass.html">ExecutePass</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="structwmtk_1_1_execute_pass-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wmtk::ExecutePass&lt; AppMesh, policy &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab0fe2d123f083cbf5ab2d7cf38a5d133"><td class="memItemLeft" align="right" valign="top"><a id="ab0fe2d123f083cbf5ab2d7cf38a5d133"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>Tuple</b> = typename AppMesh::Tuple</td></tr>
<tr class="separator:ab0fe2d123f083cbf5ab2d7cf38a5d133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa176aabc8bca91af1c1c773c6e2d00"><td class="memItemLeft" align="right" valign="top"><a id="a3aa176aabc8bca91af1c1c773c6e2d00"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OperatorFunc</b> = std::function&lt; std::optional&lt; std::vector&lt; Tuple &gt; &gt;(AppMesh &amp;, const Tuple &amp;)&gt;</td></tr>
<tr class="separator:a3aa176aabc8bca91af1c1c773c6e2d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f9cf2e8c847efac7de46a9f64c6f0ee"><td class="memItemLeft" align="right" valign="top"><a id="a4f9cf2e8c847efac7de46a9f64c6f0ee"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>OperationType</b> = std::conditional_t&lt; IsTetMesh, OperatorFunc, <a class="el" href="classwmtk_1_1_tri_mesh_operation.html">TriMeshOperation</a> &gt;</td></tr>
<tr class="separator:a4f9cf2e8c847efac7de46a9f64c6f0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5d5df67675f1e23caee2d08c0617113c"><td class="memTemplParams" colspan="2"><a id="a5d5df67675f1e23caee2d08c0617113c"></a>
template&lt;typename OpType &gt; </td></tr>
<tr class="memitem:a5d5df67675f1e23caee2d08c0617113c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_operation</b> (std::shared_ptr&lt; OpType &gt; op, const std::string &amp;name)</td></tr>
<tr class="separator:a5d5df67675f1e23caee2d08c0617113c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d522f2ac89de2353603387ef0a1fb4"><td class="memTemplParams" colspan="2"><a id="aa9d522f2ac89de2353603387ef0a1fb4"></a>
template&lt;typename OpType &gt; </td></tr>
<tr class="memitem:aa9d522f2ac89de2353603387ef0a1fb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_operation</b> (std::shared_ptr&lt; OpType &gt; op)</td></tr>
<tr class="separator:aa9d522f2ac89de2353603387ef0a1fb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f01c4f40bc693b83a6e25fba53d4be"><td class="memTemplParams" colspan="2"><a id="a23f01c4f40bc693b83a6e25fba53d4be"></a>
template&lt;typename OpType &gt; </td></tr>
<tr class="memitem:a23f01c4f40bc693b83a6e25fba53d4be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_operation</b> (const std::string &amp;name)</td></tr>
<tr class="separator:a23f01c4f40bc693b83a6e25fba53d4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b71185eca10038526a70276ae779c89"><td class="memTemplParams" colspan="2"><a id="a6b71185eca10038526a70276ae779c89"></a>
template&lt;typename OpType &gt; </td></tr>
<tr class="memitem:a6b71185eca10038526a70276ae779c89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>add_operation</b> ()</td></tr>
<tr class="separator:a6b71185eca10038526a70276ae779c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe72d11683b6cc09ef8c55796557aa32"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#afe72d11683b6cc09ef8c55796557aa32">ExecutePass</a> ()</td></tr>
<tr class="memdesc:afe72d11683b6cc09ef8c55796557aa32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new Execute Pass object. It contains the name-to-operation map and the functions that define the rules for operations.  <a href="structwmtk_1_1_execute_pass.html#afe72d11683b6cc09ef8c55796557aa32">More...</a><br /></td></tr>
<tr class="separator:afe72d11683b6cc09ef8c55796557aa32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266249d42e83c35e1d2a1b799c29d14e"><td class="memTemplParams" colspan="2"><a id="a266249d42e83c35e1d2a1b799c29d14e"></a>
template&lt;bool Tet = IsTetMesh&gt; </td></tr>
<tr class="memitem:a266249d42e83c35e1d2a1b799c29d14e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ExecutePass</b> (const std::map&lt; Op, OperatorFunc &gt; &amp;customized_ops)</td></tr>
<tr class="separator:a266249d42e83c35e1d2a1b799c29d14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2dec9f1b907e47e52faf5ea6e9c2ea"><td class="memTemplParams" colspan="2"><a id="abd2dec9f1b907e47e52faf5ea6e9c2ea"></a>
template&lt;bool Tet = IsTetMesh&gt; </td></tr>
<tr class="memitem:abd2dec9f1b907e47e52faf5ea6e9c2ea"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><b>ExecutePass</b> (const AppMesh &amp;m)</td></tr>
<tr class="separator:abd2dec9f1b907e47e52faf5ea6e9c2ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03155a3f43fae0bf5d13cf8ccbcea2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#ae03155a3f43fae0bf5d13cf8ccbcea2e">operator()</a> (AppMesh &amp;m, const std::vector&lt; std::pair&lt; Op, Tuple &gt;&gt; &amp;operation_tuples)</td></tr>
<tr class="memdesc:ae03155a3f43fae0bf5d13cf8ccbcea2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the operations for an application when the lambda function is invoked. The rules that are customizly defined for applications are applied.  <a href="structwmtk_1_1_execute_pass.html#ae03155a3f43fae0bf5d13cf8ccbcea2e">More...</a><br /></td></tr>
<tr class="separator:ae03155a3f43fae0bf5d13cf8ccbcea2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aec0c4dcc608604543139c0b61a12a866"><td class="memItemLeft" align="right" valign="top"><a id="aec0c4dcc608604543139c0b61a12a866"></a>
std::map&lt; Op, OperatorFunc &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#aec0c4dcc608604543139c0b61a12a866">edit_operation_maps</a></td></tr>
<tr class="memdesc:aec0c4dcc608604543139c0b61a12a866"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dictionary that registers names with operations. <br /></td></tr>
<tr class="separator:aec0c4dcc608604543139c0b61a12a866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069af081605674aef481d7ff254be778"><td class="memItemLeft" align="right" valign="top"><a id="a069af081605674aef481d7ff254be778"></a>
std::map&lt; Op, std::shared_ptr&lt; OperationType &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>new_edit_operation_maps</b></td></tr>
<tr class="separator:a069af081605674aef481d7ff254be778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab915e7cd93b20a81573ef291272757ee"><td class="memItemLeft" align="right" valign="top">std::function&lt; double(const AppMesh &amp;, Op op, const Tuple &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#ab915e7cd93b20a81573ef291272757ee">priority</a></td></tr>
<tr class="memdesc:ab915e7cd93b20a81573ef291272757ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Priority function (default to edge length)  <a href="structwmtk_1_1_execute_pass.html#ab915e7cd93b20a81573ef291272757ee">More...</a><br /></td></tr>
<tr class="separator:ab915e7cd93b20a81573ef291272757ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7073caa314f6fbd0e9ba43044872fa1c"><td class="memItemLeft" align="right" valign="top"><a id="a7073caa314f6fbd0e9ba43044872fa1c"></a>
std::function&lt; bool(double)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#a7073caa314f6fbd0e9ba43044872fa1c">should_renew</a> = [](auto) { return true; }</td></tr>
<tr class="memdesc:a7073caa314f6fbd0e9ba43044872fa1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">check on wheather new operations should be added to the prioirity queue <br /></td></tr>
<tr class="separator:a7073caa314f6fbd0e9ba43044872fa1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f4f220460b40510ed4ce265b696df3"><td class="memItemLeft" align="right" valign="top">std::function&lt; std::vector&lt; std::pair&lt; Op, Tuple &gt; &gt;const AppMesh &amp;, Op, const std::vector&lt; Tuple &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#af0f4f220460b40510ed4ce265b696df3">renew_neighbor_tuples</a></td></tr>
<tr class="memdesc:af0f4f220460b40510ed4ce265b696df3"><td class="mdescLeft">&#160;</td><td class="mdescRight">renew neighboring Tuples after each operation depends on the operation  <a href="structwmtk_1_1_execute_pass.html#af0f4f220460b40510ed4ce265b696df3">More...</a><br /></td></tr>
<tr class="separator:af0f4f220460b40510ed4ce265b696df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7737b4d1080c804fd46f7d7e77c98ddb"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(AppMesh &amp;, const Tuple &amp;, int task_id)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#a7737b4d1080c804fd46f7d7e77c98ddb">lock_vertices</a></td></tr>
<tr class="memdesc:a7737b4d1080c804fd46f7d7e77c98ddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">lock the vertices concerned depends on the operation  <a href="structwmtk_1_1_execute_pass.html#a7737b4d1080c804fd46f7d7e77c98ddb">More...</a><br /></td></tr>
<tr class="separator:a7737b4d1080c804fd46f7d7e77c98ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf9b2f5a9247ddce33ea9755fdd6f9b6"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(const AppMesh &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#adf9b2f5a9247ddce33ea9755fdd6f9b6">stopping_criterion</a></td></tr>
<tr class="memdesc:adf9b2f5a9247ddce33ea9755fdd6f9b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stopping Criterion based on the whole mesh For efficiency, not every time is checked. In serial, this may go over all the elements. For parallel, this involves synchronization. So there is a checking frequency.  <a href="structwmtk_1_1_execute_pass.html#adf9b2f5a9247ddce33ea9755fdd6f9b6">More...</a><br /></td></tr>
<tr class="separator:adf9b2f5a9247ddce33ea9755fdd6f9b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4842b950c3f22f8f4b358dde129f226f"><td class="memItemLeft" align="right" valign="top"><a id="a4842b950c3f22f8f4b358dde129f226f"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#a4842b950c3f22f8f4b358dde129f226f">stopping_criterion_checking_frequency</a> = std::numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="memdesc:a4842b950c3f22f8f4b358dde129f226f"><td class="mdescLeft">&#160;</td><td class="mdescRight">checking frequency to decide whether to stop execution given the stopping criterion <br /></td></tr>
<tr class="separator:a4842b950c3f22f8f4b358dde129f226f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad60058e9b843d5200ee24070f6d82da8"><td class="memItemLeft" align="right" valign="top">std::function&lt; bool(const AppMesh &amp;, const std::tuple&lt; double, Op, Tuple &gt; &amp;t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#ad60058e9b843d5200ee24070f6d82da8">is_weight_up_to_date</a></td></tr>
<tr class="memdesc:ad60058e9b843d5200ee24070f6d82da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should Process drops some Tuple from being processed. For example, if the energy is out-dated. This is in addition to calling tuple valid.  <a href="structwmtk_1_1_execute_pass.html#ad60058e9b843d5200ee24070f6d82da8">More...</a><br /></td></tr>
<tr class="separator:ad60058e9b843d5200ee24070f6d82da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a3f76d4718c918a2ceea6e7addfa52b"><td class="memItemLeft" align="right" valign="top"><a id="a1a3f76d4718c918a2ceea6e7addfa52b"></a>
std::function&lt; void(const AppMesh &amp;, Op, const Tuple &amp;t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#a1a3f76d4718c918a2ceea6e7addfa52b">on_fail</a> = [](auto&amp;, auto, auto&amp;) {}</td></tr>
<tr class="memdesc:a1a3f76d4718c918a2ceea6e7addfa52b"><td class="mdescLeft">&#160;</td><td class="mdescRight">used to collect operations that are not finished and used for later re-execution <br /></td></tr>
<tr class="separator:a1a3f76d4718c918a2ceea6e7addfa52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d3ea9d6e7ed1ea7d2c974538f5a662"><td class="memItemLeft" align="right" valign="top"><a id="a83d3ea9d6e7ed1ea7d2c974538f5a662"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>num_threads</b> = 1</td></tr>
<tr class="separator:a83d3ea9d6e7ed1ea7d2c974538f5a662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa4ec20a2b09df699a065e31d8f0758"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structwmtk_1_1_execute_pass.html#a0fa4ec20a2b09df699a065e31d8f0758">max_retry_limit</a> = 10</td></tr>
<tr class="separator:a0fa4ec20a2b09df699a065e31d8f0758"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae4c21891c3019e39cc0ff3ddb8668f7e"><td class="memItemLeft" align="right" valign="top"><a id="ae4c21891c3019e39cc0ff3ddb8668f7e"></a>
constexpr static bool&#160;</td><td class="memItemRight" valign="bottom"><b>IsTetMesh</b> = std::is_base_of_v&lt;<a class="el" href="classwmtk_1_1_tet_mesh.html">wmtk::TetMesh</a>, AppMesh&gt;</td></tr>
<tr class="separator:ae4c21891c3019e39cc0ff3ddb8668f7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a3c0be6d31f055294d559028d7ea8d2c4"><td class="memItemLeft" align="right" valign="top"><a id="a3c0be6d31f055294d559028d7ea8d2c4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operation_cleanup</b> (AppMesh &amp;m)</td></tr>
<tr class="separator:a3c0be6d31f055294d559028d7ea8d2c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eadf70a00a73556bb75af4067f7776c"><td class="memItemLeft" align="right" valign="top"><a id="a5eadf70a00a73556bb75af4067f7776c"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_partition_id</b> (const AppMesh &amp;m, const Tuple &amp;e)</td></tr>
<tr class="separator:a5eadf70a00a73556bb75af4067f7776c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afe72d11683b6cc09ef8c55796557aa32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe72d11683b6cc09ef8c55796557aa32">&#9670;&nbsp;</a></span>ExecutePass()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::<a class="el" href="structwmtk_1_1_execute_pass.html">ExecutePass</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new Execute Pass object. It contains the name-to-operation map and the functions that define the rules for operations. </p>
<dl class="section note"><dt>Note</dt><dd>the constructor is differentiated by the type of mesh, namingly <a class="el" href="classwmtk_1_1_tet_mesh.html">wmtk::TetMesh</a> or <a class="el" href="classwmtk_1_1_tri_mesh.html">wmtk::TriMesh</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae03155a3f43fae0bf5d13cf8ccbcea2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03155a3f43fae0bf5d13cf8ccbcea2e">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">AppMesh &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; Op, Tuple &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>operation_tuples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Executes the operations for an application when the lambda function is invoked. The rules that are customizly defined for applications are applied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">operation_tuples</td><td>a vector of pairs of operation's name and the Tuple to be operated on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if finished successfully </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad60058e9b843d5200ee24070f6d82da8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad60058e9b843d5200ee24070f6d82da8">&#9670;&nbsp;</a></span>is_weight_up_to_date</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool(const AppMesh&amp;, const std::tuple&lt;double, Op, Tuple&gt;&amp; t)&gt; <a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::is_weight_up_to_date</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> AppMesh&amp; m, <span class="keyword">const</span> std::tuple&lt;double, Op, Tuple&gt;&amp; t) {</div>
<div class="line">            </div>
<div class="line">            assert(std::get&lt;2&gt;(t).is_valid(m));</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        }</div>
</div><!-- fragment -->
<p>Should Process drops some Tuple from being processed. For example, if the energy is out-dated. This is in addition to calling tuple valid. </p>

</div>
</div>
<a id="a7737b4d1080c804fd46f7d7e77c98ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7737b4d1080c804fd46f7d7e77c98ddb">&#9670;&nbsp;</a></span>lock_vertices</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool(AppMesh&amp;, const Tuple&amp;, int task_id)&gt; <a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::lock_vertices</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">        [](<span class="keyword">const</span> AppMesh&amp;, <span class="keyword">const</span> Tuple&amp;, <span class="keywordtype">int</span> task_id) { <span class="keywordflow">return</span> <span class="keyword">true</span>; }</div>
</div><!-- fragment -->
<p>lock the vertices concerned depends on the operation </p>

</div>
</div>
<a id="a0fa4ec20a2b09df699a065e31d8f0758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fa4ec20a2b09df699a065e31d8f0758">&#9670;&nbsp;</a></span>max_retry_limit</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::max_retry_limit = 10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>To Avoid mutual locking, retry limit is set, and then put in a serial queue in the end. </p>

</div>
</div>
<a id="ab915e7cd93b20a81573ef291272757ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab915e7cd93b20a81573ef291272757ee">&#9670;&nbsp;</a></span>priority</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;double(const AppMesh&amp;, Op op, const Tuple&amp;)&gt; <a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::priority</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">auto</span>&amp;, <span class="keyword">auto</span>, <span class="keyword">auto</span>&amp;) {</div>
<div class="line">        <span class="keywordflow">return</span> 0.;</div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Priority function (default to edge length) </p>

</div>
</div>
<a id="af0f4f220460b40510ed4ce265b696df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f4f220460b40510ed4ce265b696df3">&#9670;&nbsp;</a></span>renew_neighbor_tuples</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;std::vector&lt;std::pair&lt;Op, Tuple&gt; &gt;const AppMesh&amp;, Op, const std::vector&lt;Tuple&gt;&amp;)&gt; <a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::renew_neighbor_tuples</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div>
<div class="line">            [](<span class="keyword">auto</span>&amp;, <span class="keyword">auto</span>, <span class="keyword">auto</span>&amp;) -&gt; std::vector&lt;std::pair&lt;Op, Tuple&gt;&gt; { <span class="keywordflow">return</span> {}; }</div>
</div><!-- fragment -->
<p>renew neighboring Tuples after each operation depends on the operation </p>

</div>
</div>
<a id="adf9b2f5a9247ddce33ea9755fdd6f9b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf9b2f5a9247ddce33ea9755fdd6f9b6">&#9670;&nbsp;</a></span>stopping_criterion</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AppMesh , ExecutionPolicy policy = ExecutionPolicy::kSeq&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;bool(const AppMesh&amp;)&gt; <a class="el" href="structwmtk_1_1_execute_pass.html">wmtk::ExecutePass</a>&lt; AppMesh, policy &gt;::stopping_criterion</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= [](<span class="keyword">const</span> AppMesh&amp;) {</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">true</span>; </div>
<div class="line">    }</div>
</div><!-- fragment -->
<p>Stopping Criterion based on the whole mesh For efficiency, not every time is checked. In serial, this may go over all the elements. For parallel, this involves synchronization. So there is a checking frequency. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>/home/runner/work/wildmeshing-toolkit/wildmeshing-toolkit/src/wmtk/<a class="el" href="_execution_scheduler_8hpp_source.html">ExecutionScheduler.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
