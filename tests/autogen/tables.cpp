#include <spdlog/spdlog.h>
#include <stdlib.h>
#include <algorithm>
#include <catch2/catch_test_macros.hpp>
#include <iostream>
#include <tuple>
#include <wmtk/Tuple.hpp>
#include <wmtk/autogen/edge_mesh/get_tuple_from_simplex_local_id.hpp>
#include <wmtk/autogen/edge_mesh/is_ccw.hpp>
#include <wmtk/autogen/edge_mesh/local_switch_tuple.hpp>
#include <wmtk/autogen/is_ccw.hpp>
#include <wmtk/autogen/local_switch_tuple.hpp>
#include <wmtk/autogen/tet_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tet_mesh/get_tuple_from_simplex_local_id.hpp>
#include <wmtk/autogen/tet_mesh/is_ccw.hpp>
#include <wmtk/autogen/tet_mesh/local_id_table_offset.hpp>
#include <wmtk/autogen/tet_mesh/local_switch_tuple.hpp>
#include <wmtk/autogen/tri_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tri_mesh/get_tuple_from_simplex_local_id.hpp>
#include <wmtk/autogen/tri_mesh/is_ccw.hpp>
#include <wmtk/autogen/tri_mesh/local_id_table_offset.hpp>
#include <wmtk/autogen/tri_mesh/local_switch_tuple.hpp>
#include "../tools/all_valid_local_tuples.hpp"

using namespace wmtk;
using namespace wmtk::autogen;
using namespace wmtk::tests;

namespace {

template <typename T>
auto get_array_range(const T& array) -> std::array<decltype(&array[0]), 2>
{
    return std::array<decltype(&array[0]), 2>{{array, array + std::size(array)}};
}
} // namespace

TEST_CASE("tuple_autogen_sizes", "[tuple]")
{
    size_t valid_face = 6;
    size_t valid_tet = 24;

    REQUIRE(all_valid_local_tuples(PrimitiveType::Triangle).size() == valid_face);
    REQUIRE(all_valid_local_tuples(PrimitiveType::Tetrahedron).size() == valid_tet);

    { // ccw check
        { // tri
            auto ccw_range = get_array_range(tri_mesh::auto_2d_table_ccw);
            size_t count =
                std::count_if(ccw_range[0], ccw_range[1], [](int64_t v) { return v != -1; });
            CHECK(count == valid_face);
        }
        {
            auto ccw_range = get_array_range(tet_mesh::auto_3d_table_ccw);
            size_t count =
                std::count_if(ccw_range[0], ccw_range[1], [](int64_t v) { return v != -1; });
            CHECK(count == valid_tet);
        }
    }
    {
        { // tri
            auto range = get_array_range(tri_mesh::auto_2d_table_vertex);
            size_t count = std::count_if(range[0], range[1], [](const int64_t v[2]) {
                return v[0] != -1 && v[1] != -1;
            });
            CHECK(count == valid_face);
        }
        { // tri
            auto range = get_array_range(tri_mesh::auto_2d_table_edge);
            size_t count = std::count_if(range[0], range[1], [](const int64_t v[2]) {
                return v[0] != -1 && v[1] != -1;
            });
            CHECK(count == valid_face);
        }
    }
    {
        { // tet
            auto range = get_array_range(tet_mesh::auto_3d_table_vertex);
            size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
                return v[0] != -1 && v[1] != -1 && v[2] != -1;
            });
            CHECK(count == valid_tet);
        }
        { // tet
            auto range = get_array_range(tet_mesh::auto_3d_table_edge);
            size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
                return v[0] != -1 && v[1] != -1 && v[2] != -1;
            });
            CHECK(count == valid_tet);
        }
        { // tet
            auto range = get_array_range(tet_mesh::auto_3d_table_face);
            size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
                return v[0] != -1 && v[1] != -1 && v[2] != -1;
            });
            CHECK(count == valid_tet);
        }
    }
}

TEST_CASE("tuple_autogen_id_inversion", "[tuple]")
{
    // when other meshes are available add them here
    for (PrimitiveType pt : {PrimitiveType::Triangle, PrimitiveType::Tetrahedron}) {
        for (int64_t idx = 0; idx < max_tuple_count(pt); ++idx) {
            Tuple t = tuple_from_offset_id(pt, idx);
            if (t.is_null()) {
                continue;
            } else {
                switch (pt) {
                case PrimitiveType::Triangle: {
                    CHECK(idx == tri_mesh::local_id_table_offset(t));
                    break;
                }
                case PrimitiveType::Tetrahedron: {
                    CHECK(idx == tet_mesh::local_id_table_offset(t));
                    break;
                }
                case PrimitiveType::Vertex:
                case PrimitiveType::Edge: break;
                }
            }
        }
    }
}

TEST_CASE("tuple_autogen_ptype_is_ccw_equivalent", "[tuple]")
{
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Edge);
        for (const auto& t : tuples) {
            CHECK(edge_mesh::is_ccw(t) == is_ccw(PrimitiveType::Edge, t));
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Triangle);
        for (const auto& t : tuples) {
            CHECK(tri_mesh::is_ccw(t) == is_ccw(PrimitiveType::Triangle, t));
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Tetrahedron);
        for (const auto& t : tuples) {
            CHECK(tet_mesh::is_ccw(t) == is_ccw(PrimitiveType::Tetrahedron, t));
        }
    }
}

TEST_CASE("tuple_autogen_local_id_inversion", "[tuple]")
{
    // NOTE: this works because we assume the unused ids are = 0; from tuple_from_offset_id
    // above
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Triangle);
        for (const auto& t : tuples) {
            int64_t id = tri_mesh::local_id_table_offset(t);
            auto [lvid, leid] = tri_mesh::lvid_leid_from_table_offset(id);
            Tuple nt(lvid, leid, -1, 0);
            int64_t nid = tri_mesh::local_id_table_offset(nt);

            CHECK(t == nt);
            CHECK(id == nid);
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Tetrahedron);
        for (const auto& t : tuples) {
            int64_t id = tet_mesh::local_id_table_offset(t);
            auto [lvid, leid, lfid] = tet_mesh::lvid_leid_lfid_from_table_offset(id);
            Tuple nt(lvid, leid, lfid, 0);
            int64_t nid = tet_mesh::local_id_table_offset(nt);
            CHECK(t == nt);
            CHECK(id == nid);
        }
    }
}

TEST_CASE("tuple_autogen_ptype_local_switch_tuple_equivalent", "[tuple]")
{
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Edge);
        for (const auto& t : tuples) {
            for (PrimitiveType pt : primitives_up_to(PrimitiveType::Edge)) {
                CHECK(
                    edge_mesh::local_switch_tuple(t, pt) ==
                    local_switch_tuple(PrimitiveType::Edge, t, pt));
            }
        }
    }
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Triangle);
        for (const auto& t : tuples) {
            for (PrimitiveType pt : primitives_up_to(PrimitiveType::Triangle)) {
                CHECK(
                    tri_mesh::local_switch_tuple(t, pt) ==
                    local_switch_tuple(PrimitiveType::Triangle, t, pt));
            }
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Tetrahedron);
        for (const auto& t : tuples) {
            for (PrimitiveType pt : primitives_up_to(PrimitiveType::Tetrahedron)) {
                CHECK(
                    tet_mesh::local_switch_tuple(t, pt) ==
                    local_switch_tuple(PrimitiveType::Tetrahedron, t, pt));
            }
        }
    }
}


TEST_CASE("tuple_autogen_switch_still_valid", "[tuple]")
{
    // when other meshes are available add them here
    for (PrimitiveType mesh_type :
         {PrimitiveType::Edge, PrimitiveType::Triangle, PrimitiveType::Tetrahedron}) {
        auto tuples = all_valid_local_tuples(mesh_type);

        for (const auto& t : tuples) {
            CHECK(tuple_is_valid_for_ccw(mesh_type, t));
            // for (PrimitiveType pt : primitives_up_to(mesh_type)) {
            //     CHECK(tuple_is_valid_for_ccw(mesh_type, local_switch_tuple(mesh_type, t,
            //     pt)));
            // }
        }
    }
}
TEST_CASE("tuple_autogen_is_ccw", "[tuple]")
{
    for (const auto& ve : tri_mesh::auto_2d_table_complete_vertex) {
        wmtk::Tuple t(ve[0], ve[1], -1, 0);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Triangle, t));
        CHECK(is_ccw(PrimitiveType::Triangle, t));
    }
    for (const auto& ve : tri_mesh::auto_2d_table_complete_edge) {
        wmtk::Tuple t(ve[0], ve[1], -1, 0);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Triangle, t));
        CHECK(is_ccw(PrimitiveType::Triangle, t));
    }
    for (const auto& ve : tet_mesh::auto_3d_table_complete_vertex) {
        wmtk::Tuple t(ve[0], ve[1], ve[2], 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Tetrahedron, t));
        CHECK(is_ccw(PrimitiveType::Tetrahedron, t));
    }
    for (const auto& ve : tet_mesh::auto_3d_table_complete_edge) {
        wmtk::Tuple t(ve[0], ve[1], ve[2], 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Tetrahedron, t));
        CHECK(is_ccw(PrimitiveType::Tetrahedron, t));
    }
    for (const auto& ve : tet_mesh::auto_3d_table_complete_face) {
        wmtk::Tuple t(ve[0], ve[1], ve[2], 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Tetrahedron, t));
        CHECK(is_ccw(PrimitiveType::Tetrahedron, t));
    }
}
TEST_CASE("tuple_autogen_from_id_is_ccw", "[tuple]")
{
    auto run_checks = [](int ic, const Tuple& t, const Tuple& t2, int i, PrimitiveType pt) {
        switch (ic) {
        case 4: REQUIRE(t.local_fid() >= 0); REQUIRE(t.local_fid() < 4);
        case 3: REQUIRE(t.local_eid() >= 0); REQUIRE(t.local_eid() < 6);
        case 2: REQUIRE(t.local_vid() >= 0); REQUIRE(t.local_vid() < 4);
        default: break;
        }
        switch (pt) {
        case PrimitiveType::Tetrahedron: CHECK(t.local_fid() == i); break;
        case PrimitiveType::Edge: CHECK(t.local_eid() == i); break;
        case PrimitiveType::Vertex: CHECK(t.local_vid() == i); break;
        default: break;
        }

        CHECK(t == t2);
    };
    PrimitiveType pt = PrimitiveType::Vertex;
    for (int i = 0; i < 2; ++i) {
        Tuple t = wmtk::autogen::edge_mesh::get_tuple_from_simplex_local_vertex_id(i, 0);
        Tuple t2 = wmtk::autogen::edge_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(2, t, t2, i, pt);
        // not every simplex has a ccw tuple in an edge_mesh
        CHECK(edge_mesh::tuple_is_valid_for_ccw(t));
        CHECK(edge_mesh::is_ccw(t) == (i == 0));
    }
    pt = PrimitiveType::Vertex;
    for (int i = 0; i < 3; ++i) {
        Tuple t = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_vertex_id(i, 0);
        Tuple t2 = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(3, t, t2, i, pt);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
    }
    pt = PrimitiveType::Edge;
    for (int i = 0; i < 3; ++i) {
        Tuple t = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_edge_id(i, 0);
        Tuple t2 = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(3, t, t2, i, pt);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
    }

    pt = PrimitiveType::Vertex;
    for (int i = 0; i < 4; ++i) {
        Tuple t = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_vertex_id(i, 0);
        Tuple t2 = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(4, t, t2, i, pt);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
    }
    pt = PrimitiveType::Edge;
    for (int i = 0; i < 6; ++i) {
        Tuple t = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_edge_id(i, 0);
        Tuple t2 = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        run_checks(4, t, t2, i, pt);
        CHECK(tet_mesh::is_ccw(t));
    }

    pt = PrimitiveType::Triangle;
    for (int i = 0; i < 4; ++i) {
        Tuple t = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_face_id(i, 0);
        Tuple t2 = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        run_checks(4, t, t2, i, pt);
        CHECK(tet_mesh::is_ccw(t));
    }
}
