#include <stdlib.h>
#include <algorithm>
#include <catch2/catch_test_macros.hpp>
#include <iostream>
#include <tuple>
#include <wmtk/Tuple.hpp>
#include <wmtk/autogen/edge_mesh/is_ccw.hpp>
#include <wmtk/autogen/edge_mesh/local_switch_tuple.hpp>
#include <wmtk/autogen/is_ccw.hpp>
#include <wmtk/autogen/local_switch_tuple.hpp>
#include <wmtk/autogen/tet_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tet_mesh/is_ccw.hpp>
#include <wmtk/autogen/tet_mesh/local_id_table_offset.hpp>
#include <wmtk/autogen/tet_mesh/local_switch_tuple.hpp>
#include <wmtk/autogen/tri_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tri_mesh/is_ccw.hpp>
#include <wmtk/autogen/tri_mesh/local_id_table_offset.hpp>
#include <wmtk/autogen/tri_mesh/local_switch_tuple.hpp>
#include "tools/all_valid_local_tuples.hpp"

using namespace wmtk;
using namespace wmtk::autogen;
using namespace wmtk::tests;


TEST_CASE("tuple_autogen_sizes", "[tuple]")
{
    size_t valid_face = 6;
    size_t valid_tet = 24;

    REQUIRE(all_valid_local_tuples(PrimitiveType::Triangle).size() == valid_face);
    REQUIRE(all_valid_local_tuples(PrimitiveType::Tetrahedron).size() == valid_tet);

    auto get_array_range = [](const auto& array) -> std::array<decltype(&array[0]), 2> {
        return std::array<decltype(&array[0]), 2>{{array, array + std::size(array)}};
    };
    {// ccw check
     {// tri
      auto ccw_range = get_array_range(tri_mesh::auto_2d_table_ccw);
    size_t count = std::count_if(ccw_range[0], ccw_range[1], [](int64_t v) { return v != -1; });
    CHECK(count == valid_face);
}
{
    auto ccw_range = get_array_range(tet_mesh::auto_3d_table_ccw);
    size_t count = std::count_if(ccw_range[0], ccw_range[1], [](int64_t v) { return v != -1; });
    CHECK(count == valid_tet);
}
}
{{// tri
  auto range = get_array_range(tri_mesh::auto_2d_table_vertex);
size_t count =
    std::count_if(range[0], range[1], [](const int64_t v[2]) { return v[0] != -1 && v[1] != -1; });
CHECK(count == valid_face);
}
{ // tri
    auto range = get_array_range(tri_mesh::auto_2d_table_edge);
    size_t count = std::count_if(range[0], range[1], [](const int64_t v[2]) {
        return v[0] != -1 && v[1] != -1;
    });
    CHECK(count == valid_face);
}
}
{
    { // tet
        auto range = get_array_range(tet_mesh::auto_3d_table_vertex);
        size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
            return v[0] != -1 && v[1] != -1 && v[2] != -1;
        });
        CHECK(count == valid_tet);
    }
    { // tet
        auto range = get_array_range(tet_mesh::auto_3d_table_edge);
        size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
            return v[0] != -1 && v[1] != -1 && v[2] != -1;
        });
        CHECK(count == valid_tet);
    }
    { // tet
        auto range = get_array_range(tet_mesh::auto_3d_table_face);
        size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
            return v[0] != -1 && v[1] != -1 && v[2] != -1;
        });
        CHECK(count == valid_tet);
    }
}
}

TEST_CASE("tuple_autogen_id_inversion", "[tuple]")
{
    // when other meshes are available add them here
    for (PrimitiveType pt : {PrimitiveType::Triangle, PrimitiveType::Tetrahedron}) {
        for (int64_t idx = 0; idx < max_tuple_count(pt); ++idx) {
            Tuple t = tuple_from_offset_id(pt, idx);
            if (t.is_null()) {
                continue;
            } else {
                switch (pt) {
                case PrimitiveType::Triangle: {
                    CHECK(idx == tri_mesh::local_id_table_offset(t));
                    break;
                }
                case PrimitiveType::Tetrahedron: {
                    CHECK(idx == tet_mesh::local_id_table_offset(t));
                    break;
                }
                case PrimitiveType::Vertex:
                case PrimitiveType::Edge: break;
                }
            }
        }
    }
}

TEST_CASE("tuple_autogen_ptype_is_ccw_equivalent", "[tuple]")
{
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Edge);
        for (const auto& t : tuples) {
            CHECK(edge_mesh::is_ccw(t) == is_ccw(PrimitiveType::Edge, t));
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Triangle);
        for (const auto& t : tuples) {
            CHECK(tri_mesh::is_ccw(t) == is_ccw(PrimitiveType::Triangle, t));
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Tetrahedron);
        for (const auto& t : tuples) {
            CHECK(tet_mesh::is_ccw(t) == is_ccw(PrimitiveType::Tetrahedron, t));
        }
    }
}

TEST_CASE("tuple_autogen_local_id_inversion", "[tuple]")
{
    // NOTE: this works because we assume the unused ids are = 0; from tuple_from_offset_id
    // above
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Triangle);
        for (const auto& t : tuples) {
            int64_t id = tri_mesh::local_id_table_offset(t);
            auto [lvid, leid] = tri_mesh::lvid_leid_from_table_offset(id);
            Tuple nt(lvid, leid, 0, 0, 0);
            int64_t nid = tri_mesh::local_id_table_offset(nt);

            CHECK(t == nt);
            CHECK(id == nid);
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Tetrahedron);
        for (const auto& t : tuples) {
            int64_t id = tet_mesh::local_id_table_offset(t);
            auto [lvid, leid, lfid] = tet_mesh::lvid_leid_lfid_from_table_offset(id);
            Tuple nt(lvid, leid, lfid, 0, 0);
            int64_t nid = tet_mesh::local_id_table_offset(nt);
            CHECK(t == nt);
            CHECK(id == nid);
        }
    }
}

TEST_CASE("tuple_autogen_ptype_local_switch_tuple_equivalent", "[tuple]")
{
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Edge);
        for (const auto& t : tuples) {
            for (PrimitiveType pt : primitives_up_to(PrimitiveType::Edge)) {
                CHECK(
                    edge_mesh::local_switch_tuple(t, pt) ==
                    local_switch_tuple(PrimitiveType::Edge, t, pt));
            }
        }
    }
    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Triangle);
        for (const auto& t : tuples) {
            for (PrimitiveType pt : primitives_up_to(PrimitiveType::Triangle)) {
                CHECK(
                    tri_mesh::local_switch_tuple(t, pt) ==
                    local_switch_tuple(PrimitiveType::Triangle, t, pt));
            }
        }
    }

    {
        auto tuples = all_valid_local_tuples(PrimitiveType::Tetrahedron);
        for (const auto& t : tuples) {
            for (PrimitiveType pt : primitives_up_to(PrimitiveType::Tetrahedron)) {
                CHECK(
                    tet_mesh::local_switch_tuple(t, pt) ==
                    local_switch_tuple(PrimitiveType::Tetrahedron, t, pt));
            }
        }
    }
}


TEST_CASE("tuple_autogen_switch_still_valid", "[tuple]")
{
    // when other meshes are available add them here
    for (PrimitiveType mesh_type : {PrimitiveType::Triangle /*, PrimitiveType::Tetrahedron*/}) {
        auto tuples = all_valid_local_tuples(mesh_type);

        for (const auto& t : tuples) {
            CHECK(tuple_is_valid_for_ccw(mesh_type, t));
            // for (PrimitiveType pt : primitives_up_to(mesh_type)) {
            //     CHECK(tuple_is_valid_for_ccw(mesh_type, local_switch_tuple(mesh_type, t,
            //     pt)));
            // }
        }
    }
}
