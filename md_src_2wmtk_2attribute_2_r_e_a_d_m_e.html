<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<!-- BEGIN opengraph metadata -->
<meta property="og:title" content="Wildmeshing" />
<meta property="og:description" content="Fast robust meshing." />
<meta property="og:url" content="https://wildmeshing.github.io" />
<!-- END opengraph metadata -->
<title>Wildmeshing Toolkit: Attribute Classes</title>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="doxygen-awesome-darkmode-toggle.js"></script>
<script type="text/javascript" src="doxygen-awesome-fragment-copy-button.js"></script>
<script type="text/javascript" src="doxygen-awesome-paragraph-link.js"></script>
<script type="text/javascript">
    DoxygenAwesomeFragmentCopyButton.init()
    DoxygenAwesomeDarkModeToggle.init()
    DoxygenAwesomeParagraphLink.init()
</script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- https://tholman.com/github-corners/ -->
<a href="https://wildmeshing.github.io" class="github-corner" title="View source on GitHub">
    <svg viewBox="0 0 250 250" width="40" height="40" style="position: absolute; top: 0; border: 0; right: 0; z-index: 99;" aria-hidden="true">
    <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="favicon.ico"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wildmeshing Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_src_2wmtk_2attribute_2_r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Attribute Classes</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md17"></a> We describe the structure of attributes and their usage. All access to attributes is guarded by several layers, where each one fulfills a different purpose. From top to bottom the layers are:</p>
<ol type="1">
<li>The <code>Mesh</code> contains an <code>AttributeManager</code>.</li>
<li>The <code>AttributeManager</code> contains type specific <code>TypedAttributeManager</code>.</li>
<li>Every <code>TypedAttributeManager</code> stores a vector of <code>CachingAttribute</code>s and a map from their names to their handles.</li>
<li>The <code>CachingAttributes</code> provide utility to revert changes on <code>Attribute</code>s.</li>
<li>The <code>Attribute</code> class is a wrapper around the raw attribute data that provides read and write functionality.</li>
<li>For referencing and accessing attributes, we use handles and accessors.</li>
</ol>
<p>In the following, we provide a summary of the most important concepts that were used in all attribute-related classes.</p>
<h3><a class="anchor" id="autotoc_md18"></a>
Attributes</h3>
<p>All properties of a mesh (including its topology) are stored in attributes. At its core, attributes are vectors:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Attribute {</div>
<div class="line">    std::vector&lt;T&gt; m_data;</div>
<div class="line">    int64_t m_dimension;</div>
<div class="line">    std::string m_name;</div>
<div class="line"> </div>
<div class="line">    Eigen::Matrix&lt;T&gt;::MapType vector_attribute(int64_t index);</div>
<div class="line">    T&amp; scalar_attribute(int64_t index);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Attributes have a <code>dimension</code>. If the <code>dimension = 1</code> then the attribute is a scalar attribute, otherwise, it is a vector attribute. This distinction is necessary for accessing the attribute. While the former case returns just a scalar, the other one returns an <code>Eigen::Map</code> (similar to a <code>Eigen::Vector</code> but without creating a copy).</p>
<p>Changes on Attributes can be reverted through the <code>CachingAttribute</code> that inherits from <code>Attribute</code>. The <code>CachingAttribute</code> holds scopes that can be pushed and popped:</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>CachingAttribute : <span class="keyword">public</span> Attribute&lt;T&gt;</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">void</span> push_scope();</div>
<div class="line">    <span class="keywordtype">void</span> pop_scope(<span class="keywordtype">bool</span> preserve_changes);</div>
<div class="line">}</div>
</div><!-- fragment --><p>The scopes work as a recording mechanism. When a new scope is pushed with <code>push_scope()</code> all changes to the attribute are tracked. When the scope is popped, the changes can either be accepted with <code>pop_scope(true)</code> or discarded with <code>pop_scope(false)</code>.</p>
<h3><a class="anchor" id="autotoc_md19"></a>
Managers</h3>
<p>All attributes of the same type are stored in a <code>TypedAttributeManager</code>. The manager deals with the registration and removal of attributes. Note that while attributes can be removed, the vector of attributes is not resized. Otherwise, <code>AttributeHandle</code>s would point to the wrong data. If the vector should be resized, e.g., for serialization/writing to file, <code>clear_dead_attributes()</code> needs to be called.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>TypedAttributeManager</div>
<div class="line">{</div>
<div class="line">    AttributeHandle register_attribute(<span class="comment">/*...*/</span>);</div>
<div class="line">    <span class="keywordtype">void</span> remove_attribute(<span class="keyword">const</span> AttributeHandle&amp; attribute);</div>
<div class="line"> </div>
<div class="line">    std::vector&lt;std::unique_ptr&lt;CachingAttribute&lt;T&gt;&gt;&gt; m_attributes;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Note that the <code>TypedAttributeManager</code> is just a data storage object and does not know anything about meshes or primitive types, e.g., vertex or edge.</p>
<p>The <code>AttributeManager</code> is a container for all <code>TypedAttributeManager</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>AttributeManager</div>
<div class="line">{</div>
<div class="line">    std::vector&lt;TypedAttributeManager&lt;char&gt;&gt; m_char_attributes;</div>
<div class="line">    std::vector&lt;TypedAttributeManager&lt;int64_t&gt;&gt; m_long_attributes;</div>
<div class="line">    std::vector&lt;TypedAttributeManager&lt;double&gt;&gt; m_double_attributes;</div>
<div class="line">    std::vector&lt;TypedAttributeManager&lt;Rational&gt;&gt; m_rational_attributes;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>Mesh</code> contains an <code>AttributeManager</code>.</p>
<h3><a class="anchor" id="autotoc_md20"></a>
Handles</h3>
<p>The <code>TypedAttributeManager</code> holds a map from names to <code>AttributeHandle</code>s. They are only for internal usage within the <code>TypedAttributeManager</code> to reference and access attributes.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>AttributeHandle</div>
<div class="line">{</div>
<div class="line">    int64_t m_index = -1;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>TypedAttributeHandle</code> is the most basic handle used outside the <code>namespace attribute</code>. It consists of an <code>AttributeHandle</code> and a <code>PrimitiveType</code>. Together with the attribute's <code>Type</code>, an attribute is uniquely defined for a single <code>Mesh</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>TypedAttributeHandle</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>Type = T;</div>
<div class="line">    AttributeHandle m_base_handle;</div>
<div class="line">    PrimitiveType m_primitive_type;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The <code>TypedAttributeHandle</code> contains a template parameter. To avoid using templates all over the place, there exists the <code>std::variant</code> <code>HandleVariant</code> in the non-templated <code>MeshAttributeHandle</code>. It also contains a reference to its <code>Mesh</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">class </span>MeshAttributeHandle</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">using </span>HandleVariant = std::variant&lt;TypedAttributeHandle&lt;char&gt;,TypedAttributeHandle&lt;int64_t&gt;,</div>
<div class="line">        TypedAttributeHandle&lt;double&gt;,TypedAttributeHandle&lt;wmtk::Rational&gt;&gt;;</div>
<div class="line">    HandleVariant&amp; handle() { <span class="keywordflow">return</span> m_handle; }</div>
<div class="line"> </div>
<div class="line">    Mesh* m_mesh = <span class="keyword">nullptr</span>;</div>
<div class="line">    HandleVariant m_handle;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The reference to the <code>Mesh</code> makes the handle unique within a multimesh, where multiple meshes might have the "same" attribute, e.g., vertex positions. The <code>MeshAttributeHandle</code> is almost always the handle that should be used. The visitor pattern must be used if someone wants to access the <code>Type</code> of an attribute from the <code>MeshAttributeHandle</code>.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Mesh m;</div>
<div class="line">MeshAttributeHandle attr;</div>
<div class="line">std::visit(</div>
<div class="line">    [&amp;m](<span class="keyword">auto</span>&amp;&amp; typed_handle) {</div>
<div class="line">        <span class="comment">// get type of the TypedAttributeHandle, e.g., TypedAttributeHandle&lt;double&gt;</span></div>
<div class="line">        <span class="keyword">using </span>HandleType = std::decay_t&lt;<span class="keyword">decltype</span>(typed_handle)&gt;;</div>
<div class="line">        <span class="comment">// get attribute data type, e.g., double</span></div>
<div class="line">        <span class="keyword">using </span>Type = <span class="keyword">typename</span> HandleType::Type;</div>
<div class="line"> </div>
<div class="line">        <span class="keywordflow">if</span> <span class="keyword">constexpr</span> (std::is_same_v&lt;Type, double&gt;) {</div>
<div class="line">            logger().info(<span class="stringliteral">&quot;Attribute {} is double&quot;</span>, m.get_attribute_name(typed_handle));</div>
<div class="line">        }</div>
<div class="line">    },</div>
<div class="line">    attr.handle());</div>
</div><!-- fragment --><p>More examples for the usage of <code>std::visit</code> are given in <em>test_accessor.cpp</em> in the test <code>"test_attribute_variant"</code>.</p>
<h3><a class="anchor" id="autotoc_md21"></a>
Accessors</h3>
<p>Handles do not know about the mesh they belong to (except for the <code>MeshAttributeHandle</code>). To access an attribute, we need the mesh to get the global ID of a simplex.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">simplex::IdSimplex s;</div>
<div class="line">int64_t idx = mesh.id(s);</div>
<div class="line">m_attribute.scalar_attribute(idx);</div>
</div><!-- fragment --><p>Also, we want to avoid the indirection of handles. They only store indices, and do not reference the attribute themselves. The <code>Accessor</code> class therefore references the attribute directly.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</div>
<div class="line"><span class="keyword">class </span>Accessor</div>
<div class="line">{</div>
<div class="line">    TypedAttributeHandle&lt;T&gt; m_handle;</div>
<div class="line">    Mesh&amp; m_mesh;</div>
<div class="line">    CachingAttribute&lt;T&gt;&amp; m_attribute;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md22"></a>
What Handle / Accessor should I use?</h1>
<p>The main advantage of the <code>MeshAttributeHandle</code> over all the other handles and the accessor is that it is type independent. If you are writing code where you do not know the data type stored in an attribute, you have to use the <code>MeshAttributeHandle</code> in combination with <code>std::visit</code>. However, most probably (at least in the first draft), you know exactly what attributes your mesh has and what types they are. In that case, we recommend creating accessors right away and passing those around.</p>
<div class="fragment"><div class="line"> ++</div>
<div class="line">Mesh m;</div>
<div class="line">MeshAttributeHandle a1 = m.register_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;a1&quot;</span>, PrimitiveType::Vertex, 1);</div>
<div class="line">Accessor&lt;double&gt; acc_a1 = m.create_accessor&lt;<span class="keywordtype">double</span>&gt;(a1);</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
<script type="text/javascript">
  $(function() {
    toggleButton = document.createElement('doxygen-awesome-dark-mode-toggle')
    toggleButton.title = "Toggle Light/Dark Mode"
    $(document).ready(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
    // every resize will remove the button, which is why it has to be added again:
    $(window).resize(function(){
      document.getElementById("MSearchBox").parentNode.appendChild(toggleButton)
    })
  })
</script>
</body>
</html>
