#include <spdlog/spdlog.h>
#include <stdlib.h>
#include <algorithm>
#include <catch2/catch_test_macros.hpp>
#include <iostream>
#include <tuple>
#include <wmtk/Tuple.hpp>
#include <wmtk/autogen/edge_mesh/get_tuple_from_simplex_local_id.hpp>
#include <wmtk/autogen/edge_mesh/is_ccw.hpp>
#include <wmtk/autogen/edge_mesh/local_switch_tuple.hpp>
#include <wmtk/autogen/is_ccw.hpp>
#include <wmtk/autogen/local_switch_tuple.hpp>
#include <wmtk/autogen/tet_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tet_mesh/get_tuple_from_simplex_local_id.hpp>
#include <wmtk/autogen/tet_mesh/is_ccw.hpp>
#include <wmtk/autogen/tet_mesh/local_id_table_offset.hpp>
#include <wmtk/autogen/tet_mesh/local_switch_tuple.hpp>
#include <wmtk/autogen/tri_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tri_mesh/get_tuple_from_simplex_local_id.hpp>
#include <wmtk/autogen/tri_mesh/is_ccw.hpp>
#include <wmtk/autogen/tri_mesh/local_id_table_offset.hpp>
#include <wmtk/autogen/tri_mesh/local_switch_tuple.hpp>
#include "../tools/all_valid_local_tuples.hpp"

using namespace wmtk;
using namespace wmtk::autogen;
using namespace wmtk::tests;

namespace {

template <typename T>
auto get_array_range(const T& array) -> std::array<decltype(&array[0]), 2>
{
    return std::array<decltype(&array[0]), 2>{{array, array + std::size(array)}};
}
} // namespace

TEST_CASE("tuple_autogen_sizes", "[tuple]")
{
    size_t valid_face = 6;
    size_t valid_tet = 24;

    {// ccw check
     {// tri
      auto ccw_range = get_array_range(tri_mesh::auto_2d_table_ccw);
    size_t count = std::count_if(ccw_range[0], ccw_range[1], [](int64_t v) { return v != -1; });
    CHECK(count == valid_face);
}
{
    auto ccw_range = get_array_range(tet_mesh::auto_3d_table_ccw);
    size_t count = std::count_if(ccw_range[0], ccw_range[1], [](int64_t v) { return v != -1; });
    CHECK(count == valid_tet);
}
}
{{// tri
  auto range = get_array_range(tri_mesh::auto_2d_table_vertex);
size_t count =
    std::count_if(range[0], range[1], [](const int64_t v[2]) { return v[0] != -1 && v[1] != -1; });
CHECK(count == valid_face);
}
{ // tri
    auto range = get_array_range(tri_mesh::auto_2d_table_edge);
    size_t count = std::count_if(range[0], range[1], [](const int64_t v[2]) {
        return v[0] != -1 && v[1] != -1;
    });
    CHECK(count == valid_face);
}
}
{
    { // tet
        auto range = get_array_range(tet_mesh::auto_3d_table_vertex);
        size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
            return v[0] != -1 && v[1] != -1 && v[2] != -1;
        });
        CHECK(count == valid_tet);
    }
    { // tet
        auto range = get_array_range(tet_mesh::auto_3d_table_edge);
        size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
            return v[0] != -1 && v[1] != -1 && v[2] != -1;
        });
        CHECK(count == valid_tet);
    }
    { // tet
        auto range = get_array_range(tet_mesh::auto_3d_table_face);
        size_t count = std::count_if(range[0], range[1], [](const int64_t v[3]) {
            return v[0] != -1 && v[1] != -1 && v[2] != -1;
        });
        CHECK(count == valid_tet);
    }
}
}

TEST_CASE("tuple_autogen_id_inversion", "[tuple]")
{
    // when other meshes are available add them here
    for (PrimitiveType pt : {PrimitiveType::Triangle, PrimitiveType::Tetrahedron}) {
        for (int64_t idx = 0; idx < max_tuple_count(pt); ++idx) {
            Tuple t = tuple_from_offset_id(pt, idx);
            if (t.is_null()) {
                continue;
            } else {
                switch (pt) {
                case PrimitiveType::Triangle: {
                    CHECK(idx == tri_mesh::local_id_table_offset(t));
                    break;
                }
                case PrimitiveType::Tetrahedron: {
                    CHECK(idx == tet_mesh::local_id_table_offset(t));
                    break;
                }
                case PrimitiveType::Vertex:
                case PrimitiveType::Edge: break;
                }
            }
        }
    }
}

TEST_CASE("tuple_autogen_is_ccw", "[tuple]")
{
    for (const auto& ve : tri_mesh::auto_2d_table_complete_vertex) {
        wmtk::Tuple t(ve[0], ve[1], -1, 0);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Triangle, t));
        CHECK(is_ccw(PrimitiveType::Triangle, t));
    }
    for (const auto& ve : tri_mesh::auto_2d_table_complete_edge) {
        wmtk::Tuple t(ve[0], ve[1], -1, 0);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Triangle, t));
        CHECK(is_ccw(PrimitiveType::Triangle, t));
    }
    for (const auto& ve : tet_mesh::auto_3d_table_complete_vertex) {
        wmtk::Tuple t(ve[0], ve[1], ve[2], 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Tetrahedron, t));
        CHECK(is_ccw(PrimitiveType::Tetrahedron, t));
    }
    for (const auto& ve : tet_mesh::auto_3d_table_complete_edge) {
        wmtk::Tuple t(ve[0], ve[1], ve[2], 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Tetrahedron, t));
        CHECK(is_ccw(PrimitiveType::Tetrahedron, t));
    }
    for (const auto& ve : tet_mesh::auto_3d_table_complete_face) {
        wmtk::Tuple t(ve[0], ve[1], ve[2], 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
        CHECK(tuple_is_valid_for_ccw(PrimitiveType::Tetrahedron, t));
        CHECK(is_ccw(PrimitiveType::Tetrahedron, t));
    }
}
TEST_CASE("tuple_autogen_from_id_is_ccw", "[tuple]")
{
    auto run_checks = [](int ic, const Tuple& t, const Tuple& t2, int i, PrimitiveType pt) {
        switch (ic) {
        case 4: REQUIRE(t.local_fid() >= 0); REQUIRE(t.local_fid() < 4);
        case 3: REQUIRE(t.local_eid() >= 0); REQUIRE(t.local_eid() < 6);
        case 2: REQUIRE(t.local_vid() >= 0); REQUIRE(t.local_vid() < 4);
        default: break;
        }
        switch (pt) {
        case PrimitiveType::Tetrahedron: CHECK(t.local_fid() == i); break;
        case PrimitiveType::Edge: CHECK(t.local_eid() == i); break;
        case PrimitiveType::Vertex: CHECK(t.local_vid() == i); break;
        default: break;
        }

        CHECK(t == t2);
    };
    PrimitiveType pt = PrimitiveType::Vertex;
    for (int i = 0; i < 2; ++i) {
        Tuple t = wmtk::autogen::edge_mesh::get_tuple_from_simplex_local_vertex_id(i, 0);
        Tuple t2 = wmtk::autogen::edge_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(2, t, t2, i, pt);
        // not every simplex has a ccw tuple in an edge_mesh
        CHECK(edge_mesh::tuple_is_valid_for_ccw(t));
        CHECK(edge_mesh::is_ccw(t) == (i == 0));
    }
    pt = PrimitiveType::Vertex;
    for (int i = 0; i < 3; ++i) {
        Tuple t = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_vertex_id(i, 0);
        Tuple t2 = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(3, t, t2, i, pt);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
    }
    pt = PrimitiveType::Edge;
    for (int i = 0; i < 3; ++i) {
        Tuple t = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_edge_id(i, 0);
        Tuple t2 = wmtk::autogen::tri_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(3, t, t2, i, pt);
        CHECK(tri_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tri_mesh::is_ccw(t));
    }

    pt = PrimitiveType::Vertex;
    for (int i = 0; i < 4; ++i) {
        Tuple t = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_vertex_id(i, 0);
        Tuple t2 = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        run_checks(4, t, t2, i, pt);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        CHECK(tet_mesh::is_ccw(t));
    }
    pt = PrimitiveType::Edge;
    for (int i = 0; i < 6; ++i) {
        Tuple t = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_edge_id(i, 0);
        Tuple t2 = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        run_checks(4, t, t2, i, pt);
        CHECK(tet_mesh::is_ccw(t));
    }

    pt = PrimitiveType::Triangle;
    for (int i = 0; i < 4; ++i) {
        Tuple t = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_face_id(i, 0);
        Tuple t2 = wmtk::autogen::tet_mesh::get_tuple_from_simplex_local_id(pt, i, 0);
        CHECK(tet_mesh::tuple_is_valid_for_ccw(t));
        run_checks(4, t, t2, i, pt);
        CHECK(tet_mesh::is_ccw(t));
    }
}
