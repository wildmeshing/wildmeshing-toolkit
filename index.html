<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wildmeshing Toolkit: Wildmeshing-toolkit: Declarative Specification for Unstructured Mesh Editing Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wildmeshing Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Wildmeshing-toolkit: Declarative Specification for Unstructured Mesh Editing Algorithms </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="md__opt_wmtk_wildmeshing_actions_runner__work_wildmeshing_toolkit_wildmeshing_toolkit_README"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Installation</h1>
<h3><a class="anchor" id="autotoc_md2"></a>
via CMake</h3>
<ul>
<li>Clone the repository into your local machine:</li>
</ul>
<div class="fragment"><div class="line">git clone https://github.com/wildmeshing/wildmeshing-toolkit.git</div>
</div><!-- fragment --><ul>
<li>Compile the code using cmake&gt;3.20.0</li>
</ul>
<div class="fragment"><div class="line">cd wildmeshing-toolkit</div>
<div class="line">mkdir build</div>
<div class="line">cd build</div>
<div class="line">cmake -DCMAKE_BUILD_TYPE=Release ..</div>
<div class="line">make</div>
</div><!-- fragment --><p>You may need to install <code>gmp</code> before compiling the code. You can install <code>gmp</code> via <a href="https://brew.sh/">homebrew</a>.</p>
<h1><a class="anchor" id="autotoc_md3"></a>
Usage</h1>
<p>To reproduce figures from the paper, please use the commands from <a href="reproduce_scripts.sh">reproduce_scripts</a>. Note that the input data are from <code>wmtk-data-package.zip</code>. (Download: <a href="https://drive.google.com/drive/folders/1jFdQ77E2_n3EJF5_bPOOMEOxF4dyctjN?usp=sharing">https://drive.google.com/drive/folders/1jFdQ77E2_n3EJF5_bPOOMEOxF4dyctjN?usp=sharing</a>)</p>
<h1><a class="anchor" id="autotoc_md4"></a>
About Us</h1>
<p>This toolkit is a novel approach to describe mesh generation, mesh adaptation, and geometric modeling algorithms relying on changing mesh connectivity using a high-level abstraction. The main motivation is to enable easy customization and development of these algorithms via a declarative specification consisting of a set of per-element invariants, operation scheduling,and attribute transfer for each editing operation.</p>
<p>Many widely used algorithms editing surfaces and volumes can be compactly expressed with our abstraction, and their implementation within our framework is simple, automatically parallelizable on shared- memory architectures, and with guaranteed satisfaction of the prescribed invariants. These algorithms are readable and easy to customize for specific use cases.</p>
<p>This software library implements the abstractiona in our paper and providing automatic shared memory parallelization.</p>
<p>We will use the implementation of the shortest edge collapse algorithm as an example to introduce the framework and run through the basic software structures and APIs of the toolkit. All the code that is referenced below can be found under the <code>app</code> folder of the toolkit.</p>
<h1><a class="anchor" id="autotoc_md5"></a>
Basic Algorithm</h1>
<p>The algorithm is after [Hoppe 1996] Progressive Meshes which performs a series of collapse operations prioritizing the shorter edges. The algorithm requires only one local operation, edge collapse. We terminate when the mesh reaches a desired number of mesh elements. For every collapsed edge, we generate a new vertex at the midpoint of the edge.</p>
<p>We implemented <code>class ShortestEdgeCollapse</code> as a child class of <code><a class="el" href="classwmtk_1_1_tri_mesh.html">wmtk::TriMesh</a></code>. The 3d vertex positions are stored as a field of the <code>VertexAttributes</code>. </p><div class="fragment"><div class="line">struct VertexAttributes</div>
<div class="line">{</div>
<div class="line"> &gt;&gt; Eigen::Vector3d pos;</div>
<div class="line">    size_t partition_id = 0;</div>
<div class="line">    bool freeze = false;</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md6"></a>
Explicit Invariant Design</h1>
<p>It is common to have a set of desiderata on the mesh that needs to be satisfied, such as avoiding triangle insertions or self-intersections. The responsibility of ensuring the user-defined explicit invariants being checked after every mesh modification, and after the input is loaded is assumed by the toolkit. It is much easier to ensure correctness for the user, as the checks are handled transparently by the toolkit.</p>
<p>As an example of user-defined invariants, in our shortest edge collapse implementation, we created an envelope around the original surface and designated that any operation shall not cause any vertex to move outside of the envelop, so that during local operations we can roughly keep the shape of the input mesh and avoid self-intersection.</p>
<div class="fragment"><div class="line">bool sec::ShortestEdgeCollapse::invariants(const std::vector&lt;Tuple&gt;&amp; new_tris)</div>
<div class="line">{</div>
<div class="line">    if (m_has_envelope) {</div>
<div class="line">        for (auto&amp; t : new_tris) {</div>
<div class="line">            std::array&lt;Eigen::Vector3d, 3&gt; tris;</div>
<div class="line">            auto vs = oriented_tri_vertices(t);</div>
<div class="line">            for (auto j = 0; j &lt; 3; j++) tris[j] = vertex_attrs[vs[j].vid(*this)].pos;</div>
<div class="line">            bool outside = m_envelope.is_outside(tris);</div>
<div class="line">            if (outside) return false;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    return true;</div>
<div class="line">}</div>
</div><!-- fragment --><p> The envelope development is after <a href="https://cims.nyu.edu/gcl/papers/2020-Fast-Envelope.pdf">Exact and Efficient Polyhedral Envelope Containment Check</a></p>
<h1><a class="anchor" id="autotoc_md7"></a>
Explicit Attribute Update</h1>
<p>Opposed to the common practice of attaching mesh attributes to mesh elements we enable the users to only provide the rules on how to update attributes after local operations in a high-level specifications. The actual update is handled entirely by the toolkit.</p>
<p>This easy-to-write user-specified update rule is examplified in our shortest edge collapse as below </p><div class="fragment"><div class="line">bool sec::ShortestEdgeCollapse::collapse_edge_after(const TriMesh::Tuple&amp; t)</div>
<div class="line">{</div>
<div class="line">    const Eigen::Vector3d p = (position_cache.local().v1p + position_cache.local().v2p) / 2.0;</div>
<div class="line">    auto vid = t.vid(*this);</div>
<div class="line">    vertex_attrs[vid].pos = p;</div>
<div class="line"> </div>
<div class="line">    return true;</div>
<div class="line">}</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md8"></a>
Operation Rollback</h1>
<p>It is common to perform mesh editing to improve a given energy functional, such as mesh quality or element size. However, due to the discrete nature of the operations, it is not possible to use standard smooth optimization techniques, and instead the effect of the energy is evaluated before and after every operation to measure its effect on the energy. If the user desires a certain property of the mesh for each operation, the desiderata can be easily coded up as a check in the after operation.</p>
<p>If either the user specified invariants or the after operation check/update has failed, the toolkit will perform an operation rollback that restores the mesh configuration to before the operation. And our toolkit also handles the recovery of element attributes on this occasion. The rollback and attribute protection gurantee both topology and geometry consistency for the mesh. Users would not need to perform any manual updates were the operations to fail, thank to the rollback.</p>
<h1><a class="anchor" id="autotoc_md9"></a>
Operation Demonstration</h1>
<p>For easier usage and customization, here we demonstrate the before and after of each operation and the vertex, edge, face, and tet (in 3d) that is reference.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
2D operations</h2>
<ul>
<li><b>edge collapse</b> <img src="img/collapse_demonstration.svg" alt="img" style="pointer-events: none;" class="inline"/></li>
<li><b>edge split</b> <img src="img/split_demonstration.svg" alt="img" style="pointer-events: none;" class="inline"/></li>
<li><b>edge swap</b> <img src="img/swap_demonstration.svg" alt="img" style="pointer-events: none;" class="inline"/></li>
<li><b>vertex smooth</b> This operation do not change the reference.</li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
3D operations</h2>
<ul>
<li><b>edge collapse</b> <img src="img/collapse3d.PNG" alt="img" class="inline"/></li>
<li><b>edge collapse boundary case</b> <img src="img/collapseboundary3d.PNG" alt="img" class="inline"/></li>
<li><b>edge split</b> <img src="img/split3d.PNG" alt="img" class="inline"/></li>
<li><b>edge swap 4-4</b> <img src="img/swap44.PNG" alt="img" class="inline"/></li>
<li><b>edge swap 2-3 &amp; 3-2</b> <img src="img/swap32.PNG" alt="img" class="inline"/></li>
</ul>
<h1><a class="anchor" id="autotoc_md12"></a>
Parallel Scheduling</h1>
<p>The type and scheduling of local operations is crucial in mesh editing algorithms. This involves maintaining a priority queue of operations, which is updated after every local operation.</p>
<p>We provide a direct way of controlling the operations performed and how the queue is updated through our scheduler. The main purpose of the scheduler is to abstract the operation order and hide parallelization details from the user. Our scheduler provides customizable callbacks, including, <em>Priority</em>, <em>Renew neighbor</em>, <em>Lock vertices</em>, <em>Stopping criterion</em>. <br  />
</p>
<p>For shortest edge collapse, we want to attempt to collapse all edges, prioritizing the shortest ones, until we reach a fixed number of vertices.</p>
<div class="fragment"><div class="line">for (auto&amp; loc : get_edges()) collect_all_ops.emplace_back(&quot;edge_collapse&quot;, loc);</div>
</div><!-- fragment --><p>We put here the example of our shortest edge collapse implementation of the <em>Priority</em> and <em>Renew neighbor</em>, and how they are used in scheduler. </p><div class="fragment"><div class="line">auto renew = [](auto&amp; m, auto op, auto&amp; tris) {</div>
<div class="line">    auto edges = m.new_edges_after(tris);</div>
<div class="line">    auto optup = std::vector&lt;std::pair&lt;std::string, Tuple&gt;&gt;();</div>
<div class="line">    for (auto&amp; e : edges) optup.emplace_back(&quot;edge_collapse&quot;, e);</div>
<div class="line">    return optup;</div>
<div class="line">};</div>
<div class="line">auto measure_len2 = [](auto&amp; m, auto op, const Tuple&amp; new_e) {</div>
<div class="line">    auto len2 =</div>
<div class="line">        (m.vertex_attrs[new_e.vid(m)].pos - m.vertex_attrs[new_e.switch_vertex(m).vid(m)].pos)</div>
<div class="line">            .squaredNorm();</div>
<div class="line">    return -len2;</div>
<div class="line">};</div>
<div class="line">auto setup_and_execute = [&amp;](auto executor) {</div>
<div class="line">    executor.num_threads = NUM_THREADS;</div>
<div class="line">&gt;&gt; executor.renew_neighbor_tuples = renew;</div>
<div class="line">&gt;&gt; executor.priority = measure_len2;</div>
<div class="line">    executor.stopping_criterion_checking_frequency =</div>
<div class="line">        target_vert_number &gt; 0 ? (initial_size - target_vert_number - 1)</div>
<div class="line">                                : std::numeric_limits&lt;int&gt;::max();</div>
<div class="line">    executor.stopping_criterion = [](auto&amp; m) { return true; };</div>
<div class="line">    executor(*this, collect_all_ops);</div>
<div class="line">};</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md13"></a>
Command Line Executions for Example Applications</h1>
<p>To showcase the generality and effectiveness of our approach, we implemented five popular mesh editing algorithms in our framework. We provide the command lines and corresponding parameters for running the these applications as below:</p>
<div class="fragment"><div class="line">cd build</div>
</div><!-- fragment --><ul>
<li>### Shortest Edge Collpase : <a href="https://hhoppe.com/pm.pdf">Progressive Meshes</a> <div class="fragment"><div class="line">Usage:./app/sec_app input output [OPTIONS] </div>
<div class="line"> </div>
<div class="line">Required:</div>
<div class="line">  input                       Input surface mesh INPUT in .off/.obj/.stl/.ply format. </div>
<div class="line">  output                      Output tetmesh OUTPUT in .obj format. </div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  -e,--envelope               Relative envelope size. enveleope_size = diag_of_bbox * e. negative to disable.</div>
<div class="line">  -j, --thread thread         Thread number.</div>
<div class="line">  -t, --target                Percentage of input vertices in output.</div>
</div><!-- fragment --></li>
<li>### Qslim : <a href="https://dl.acm.org/doi/pdf/10.1145/258734.258849">Surface Simplification Using Quadric Error Metrics</a> <div class="fragment"><div class="line">Usage:./app/qslim_app input output [OPTIONS] </div>
<div class="line"> </div>
<div class="line">Required:</div>
<div class="line">  input                       Input surface mesh INPUT in .off/.obj/.stl/.ply format. </div>
<div class="line">  output                      Output tetmesh OUTPUT in .obj format. </div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  -e,--envelope               Relative envelope size. enveleope_size = diag_of_bbox * e. negative to disable.</div>
<div class="line">  -j, --thread thread         Thread number.</div>
<div class="line">  -t, --target                Percentage of input vertices in output.</div>
</div><!-- fragment --></li>
<li>### Isotropic Remeshing : <a href="https://ls7-gv.cs.tu-dortmund.de/downloads/publications/2004/sgp04.pdf">A Remeshing Approach to Multiresolution Modeling</a> <div class="fragment"><div class="line">Usage:./app/remeshing_app input output [OPTIONS] </div>
<div class="line"> </div>
<div class="line">Required:</div>
<div class="line">  input                       Input surface mesh INPUT in .off/.obj/.stl/.ply format. </div>
<div class="line">  output                      Output tetmesh OUTPUT in .obj format. </div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  -e,--envelope               Relative envelope size. enveleope_size = diag_of_bbox * e negative to disable.</div>
<div class="line">  -j, --thread thread         Thread number.</div>
<div class="line">  -r, --relativelength        Relative edge length. Target edge length in output mesh is min(diag * rel_len, 5 * avg_len).</div>
<div class="line">  -a, --absolutelengt         Absolute edge length in output mesh.</div>
<div class="line">  -i, --iterations            Number of remeshing itrs.</div>
<div class="line">  -f, --freeze                To freeze the boundary, default to true.</div>
<div class="line">  --sample-envelope           use sample envelope, default to false.</div>
</div><!-- fragment --></li>
<li>### Harmonic Triangulations : <a href="https://dl.acm.org/doi/pdf/10.1145/3306346.3322986">Harmonic Triangulations</a> <div class="fragment"><div class="line">Usage:</div>
<div class="line">./app/harmonic_tet/wmtk_harmonic_tet_bin input output </div>
<div class="line"> </div>
<div class="line">Required:</div>
<div class="line">  input                       Input surface mesh INPUT in .off/.obj/.stl/.ply format. </div>
<div class="line">  output                      Output tetmesh OUTPUT in .msh format. </div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  -j, --thread thread         Thread number.</div>
<div class="line">  --harmonize                 Enable to use for point cloud.</div>
</div><!-- fragment --></li>
<li>### Tetwild : <a href="https://cims.nyu.edu/gcl/papers/2018-TetWild.pdf">Tetrahedral Meshing in the Wild</a> <div class="fragment"><div class="line">Usage:</div>
<div class="line">./app/tetwild/tetwild -i input -o output</div>
<div class="line"> </div>
<div class="line">Required:</div>
<div class="line">  input                       Input surface mesh INPUT in .off/.obj/.stl/.ply format. </div>
<div class="line">  output                      Output tetmesh OUTPUT in .msh format. </div>
<div class="line"> </div>
<div class="line">Options:</div>
<div class="line">  -e,--epsr                   Relative envelope size. enveleope_size = diag_of_bbox * e negative to disable.</div>
<div class="line">  -j, --thread thread         Thread number.</div>
<div class="line">  --skip-simplify             Skip simplify_input.</div>
<div class="line">  --max-its                   Max # its.</div>
<div class="line">  -r, --rlen                  Relative ideal edge length wrt diag of bbox.</div>
<div class="line">  --filter-with-input         Filter with input mesh, default is tracked surface.</div>
<div class="line">  --sample-envelope           Use sample envelope for both simp and optim.</div>
</div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="autotoc_md14"></a>
License</h1>
<p>MIT License. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
