<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Wildmeshing Toolkit: wmtk::Mesh Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Wildmeshing Toolkit
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>wmtk</b></li><li class="navelem"><a class="el" href="classwmtk_1_1_mesh.html">Mesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classwmtk_1_1_mesh-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wmtk::Mesh Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for wmtk::Mesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classwmtk_1_1_mesh.png" usemap="#wmtk::Mesh_map" alt=""/>
  <map id="wmtk::Mesh_map" name="wmtk::Mesh_map">
<area href="classwmtk_1_1utils_1_1_merkle_tree_interior_node.html" alt="wmtk::utils::MerkleTreeInteriorNode" shape="rect" coords="482,56,713,80"/>
<area href="classwmtk_1_1utils_1_1_hashable.html" alt="wmtk::utils::Hashable" shape="rect" coords="482,0,713,24"/>
<area href="classwmtk_1_1_edge_mesh.html" alt="wmtk::EdgeMesh" shape="rect" coords="0,168,231,192"/>
<area href="classwmtk_1_1_point_mesh.html" alt="wmtk::PointMesh" shape="rect" coords="241,168,472,192"/>
<area href="classwmtk_1_1_tet_mesh.html" alt="wmtk::TetMesh" shape="rect" coords="482,168,713,192"/>
<area href="classwmtk_1_1_tri_mesh.html" alt="wmtk::TriMesh" shape="rect" coords="723,168,954,192"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afb47df0f355dc986263814c671fbe77e"><td class="memItemLeft" align="right" valign="top"><a id="afb47df0f355dc986263814c671fbe77e"></a>
virtual long&#160;</td><td class="memItemRight" valign="bottom"><b>top_cell_dimension</b> () const =0</td></tr>
<tr class="separator:afb47df0f355dc986263814c671fbe77e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaf00438d0700358b160e310d69725c9"><td class="memItemLeft" align="right" valign="top"><a id="abaf00438d0700358b160e310d69725c9"></a>
PrimitiveType&#160;</td><td class="memItemRight" valign="bottom"><b>top_simplex_type</b> () const</td></tr>
<tr class="separator:abaf00438d0700358b160e310d69725c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b247a8c27eecfc68b7bbbddc0972ca8"><td class="memItemLeft" align="right" valign="top"><a id="a8b247a8c27eecfc68b7bbbddc0972ca8"></a>
std::map&lt; std::string, const <a class="el" href="classwmtk_1_1utils_1_1_hashable.html">wmtk::utils::Hashable</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>child_hashables</b> () const override</td></tr>
<tr class="separator:a8b247a8c27eecfc68b7bbbddc0972ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44312378ef9c1236ece090f7dcdd0ba9"><td class="memItemLeft" align="right" valign="top"><a id="a44312378ef9c1236ece090f7dcdd0ba9"></a>
std::map&lt; std::string, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>child_hashes</b> () const override</td></tr>
<tr class="separator:a44312378ef9c1236ece090f7dcdd0ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094bf35730bdb3f5359c192b1e0b2029"><td class="memItemLeft" align="right" valign="top"><a id="a094bf35730bdb3f5359c192b1e0b2029"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (const long &amp;dimension)</td></tr>
<tr class="separator:a094bf35730bdb3f5359c192b1e0b2029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1df3c5207b12c033fac6e476a8c2fcb"><td class="memItemLeft" align="right" valign="top"><a id="aa1df3c5207b12c033fac6e476a8c2fcb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (const long &amp;dimension, const long &amp;max_primitive_type_id, PrimitiveType hash_type)</td></tr>
<tr class="separator:aa1df3c5207b12c033fac6e476a8c2fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac1b58f33df36fc07f54dbe8e9abceb0"><td class="memItemLeft" align="right" valign="top"><a id="aac1b58f33df36fc07f54dbe8e9abceb0"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&amp;other)</td></tr>
<tr class="separator:aac1b58f33df36fc07f54dbe8e9abceb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3208e43d6e462c98ba74027f10d5ca6"><td class="memItemLeft" align="right" valign="top"><a id="ae3208e43d6e462c98ba74027f10d5ca6"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Mesh</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other)</td></tr>
<tr class="separator:ae3208e43d6e462c98ba74027f10d5ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98be65deb2723ecbba890fcce0f779a5"><td class="memItemLeft" align="right" valign="top"><a id="a98be65deb2723ecbba890fcce0f779a5"></a>
<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other)</td></tr>
<tr class="separator:a98be65deb2723ecbba890fcce0f779a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2481d032d7e83b7b28bd4207eb023567"><td class="memItemLeft" align="right" valign="top"><a id="a2481d032d7e83b7b28bd4207eb023567"></a>
<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&amp;other)</td></tr>
<tr class="separator:a2481d032d7e83b7b28bd4207eb023567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b60c718ac7eeb8b41e1496473c9a519"><td class="memItemLeft" align="right" valign="top"><a id="a0b60c718ac7eeb8b41e1496473c9a519"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>serialize</b> (<a class="el" href="classwmtk_1_1_mesh_writer.html">MeshWriter</a> &amp;writer)</td></tr>
<tr class="separator:a0b60c718ac7eeb8b41e1496473c9a519"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d2a546c8f661bf6386cf845a1693d2f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a6d2a546c8f661bf6386cf845a1693d2f">get_all</a> (PrimitiveType type) const</td></tr>
<tr class="separator:a6d2a546c8f661bf6386cf845a1693d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e8ede2e60df546bb323fc47e2338c25"><td class="memItemLeft" align="right" valign="top">virtual std::tuple&lt; std::vector&lt; std::vector&lt; long &gt; &gt;, std::vector&lt; std::vector&lt; long &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a0e8ede2e60df546bb323fc47e2338c25">consolidate</a> ()</td></tr>
<tr class="separator:a0e8ede2e60df546bb323fc47e2338c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf9ba1745bd07a33dcfa8b679e33290"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::vector&lt; <a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; long &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a9bf9ba1745bd07a33dcfa8b679e33290">connectivity_attributes</a> () const =0</td></tr>
<tr class="separator:a9bf9ba1745bd07a33dcfa8b679e33290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f763f104eb05f83125d41baa8c747"><td class="memTemplParams" colspan="2"><a id="a003f763f104eb05f83125d41baa8c747"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a003f763f104eb05f83125d41baa8c747"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1attribute_1_1_attribute_initialization_handle.html">attribute::AttributeInitializationHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>register_attribute</b> (const std::string &amp;name, PrimitiveType type, long size, bool replace=false, T default_value=T(0))</td></tr>
<tr class="separator:a003f763f104eb05f83125d41baa8c747"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce03b279d7451b8cf46d6cf1899a2a0"><td class="memTemplParams" colspan="2"><a id="a9ce03b279d7451b8cf46d6cf1899a2a0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ce03b279d7451b8cf46d6cf1899a2a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>register_attribute_nomesh</b> (const std::string &amp;name, PrimitiveType type, long size, bool replace=false, T default_value=T(0))</td></tr>
<tr class="separator:a9ce03b279d7451b8cf46d6cf1899a2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b735bef9cbf8d5ab955d23f787b70f"><td class="memTemplParams" colspan="2"><a id="a89b735bef9cbf8d5ab955d23f787b70f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a89b735bef9cbf8d5ab955d23f787b70f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><b>has_attribute</b> (const std::string &amp;name, const PrimitiveType ptype) const</td></tr>
<tr class="separator:a89b735bef9cbf8d5ab955d23f787b70f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785a0fcdd17dde2ddec3aec2e4fe9259"><td class="memTemplParams" colspan="2"><a id="a785a0fcdd17dde2ddec3aec2e4fe9259"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a785a0fcdd17dde2ddec3aec2e4fe9259"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1attribute_1_1_mesh_attribute_handle.html">MeshAttributeHandle</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_attribute_handle</b> (const std::string &amp;name, const PrimitiveType ptype) const</td></tr>
<tr class="separator:a785a0fcdd17dde2ddec3aec2e4fe9259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b80238a687153168975179b69f57469"><td class="memTemplParams" colspan="2"><a id="a9b80238a687153168975179b69f57469"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9b80238a687153168975179b69f57469"><td class="memTemplItemLeft" align="right" valign="top">Accessor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_accessor</b> (const <a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; T &gt; &amp;handle)</td></tr>
<tr class="separator:a9b80238a687153168975179b69f57469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a33a7e7fbfd7c9d5588f0a392783047"><td class="memTemplParams" colspan="2"><a id="a0a33a7e7fbfd7c9d5588f0a392783047"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0a33a7e7fbfd7c9d5588f0a392783047"><td class="memTemplItemLeft" align="right" valign="top">ConstAccessor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_const_accessor</b> (const <a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; T &gt; &amp;handle) const</td></tr>
<tr class="separator:a0a33a7e7fbfd7c9d5588f0a392783047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c98ad25b145b54241f1d9c335d2dc5"><td class="memTemplParams" colspan="2"><a id="a34c98ad25b145b54241f1d9c335d2dc5"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a34c98ad25b145b54241f1d9c335d2dc5"><td class="memTemplItemLeft" align="right" valign="top">ConstAccessor&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>create_accessor</b> (const <a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; T &gt; &amp;handle) const</td></tr>
<tr class="separator:a34c98ad25b145b54241f1d9c335d2dc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e450ec6092893d1712cf4872dde36df"><td class="memTemplParams" colspan="2"><a id="a1e450ec6092893d1712cf4872dde36df"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1e450ec6092893d1712cf4872dde36df"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_attribute_dimension</b> (const <a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; T &gt; &amp;handle) const</td></tr>
<tr class="separator:a1e450ec6092893d1712cf4872dde36df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c80d92eb6c801b64d52444a9f98d4d3"><td class="memTemplParams" colspan="2"><a id="a9c80d92eb6c801b64d52444a9f98d4d3"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9c80d92eb6c801b64d52444a9f98d4d3"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_attribute_name</b> (const <a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; T &gt; &amp;handle) const</td></tr>
<tr class="separator:a9c80d92eb6c801b64d52444a9f98d4d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75c72ea3e05b6d7b3ab3981589762d1f"><td class="memItemLeft" align="right" valign="top"><a id="a75c72ea3e05b6d7b3ab3981589762d1f"></a>
<a class="el" href="classwmtk_1_1multimesh_1_1attribute_1_1_attribute_scope_handle.html">multimesh::attribute::AttributeScopeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_scope</b> ()</td></tr>
<tr class="separator:a75c72ea3e05b6d7b3ab3981589762d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5778c1f8afef3a2b1b1c33a140b3166"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ac5778c1f8afef3a2b1b1c33a140b3166"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#ac5778c1f8afef3a2b1b1c33a140b3166">parent_scope</a> (Functor &amp;&amp;f, Args &amp;&amp;... args) const</td></tr>
<tr class="memdesc:ac5778c1f8afef3a2b1b1c33a140b3166"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluate the passed in function inside the parent scope. The parent_scope function can be nested to reach deeper levels in the scope stack.  <a href="classwmtk_1_1_mesh.html#ac5778c1f8afef3a2b1b1c33a140b3166">More...</a><br /></td></tr>
<tr class="separator:ac5778c1f8afef3a2b1b1c33a140b3166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a112e2b6207157042f792ca9b12601abf"><td class="memItemLeft" align="right" valign="top"><a id="a112e2b6207157042f792ca9b12601abf"></a>
ConstAccessor&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_flag_accessor</b> (PrimitiveType type) const</td></tr>
<tr class="separator:a112e2b6207157042f792ca9b12601abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b4b5a55b5f688f2a03c1f2752e7cee"><td class="memItemLeft" align="right" valign="top"><a id="a30b4b5a55b5f688f2a03c1f2752e7cee"></a>
ConstAccessor&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_cell_hash_accessor</b> () const</td></tr>
<tr class="separator:a30b4b5a55b5f688f2a03c1f2752e7cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3793b1f71479e8b68632f21b32ec3175"><td class="memItemLeft" align="right" valign="top"><a id="a3793b1f71479e8b68632f21b32ec3175"></a>
ConstAccessor&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_const_flag_accessor</b> (PrimitiveType type) const</td></tr>
<tr class="separator:a3793b1f71479e8b68632f21b32ec3175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6123da2ad5494edab108643c6cd549c"><td class="memItemLeft" align="right" valign="top"><a id="ae6123da2ad5494edab108643c6cd549c"></a>
ConstAccessor&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_const_cell_hash_accessor</b> () const</td></tr>
<tr class="separator:ae6123da2ad5494edab108643c6cd549c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e808b3c4f09b5af0e2af25f71d02c2"><td class="memItemLeft" align="right" valign="top"><a id="ac8e808b3c4f09b5af0e2af25f71d02c2"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>get_cell_hash</b> (long cell_index, const ConstAccessor&lt; long &gt; &amp;hash_accessor) const</td></tr>
<tr class="separator:ac8e808b3c4f09b5af0e2af25f71d02c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6288e646fb700eeb3468c59d7ea0204a"><td class="memItemLeft" align="right" valign="top"><a id="a6288e646fb700eeb3468c59d7ea0204a"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>get_cell_hash_slow</b> (long cell_index) const</td></tr>
<tr class="separator:a6288e646fb700eeb3468c59d7ea0204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956aac44b94a5742b67e721dfe4ee978"><td class="memItemLeft" align="right" valign="top"><a id="a956aac44b94a5742b67e721dfe4ee978"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>operator==</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other) const</td></tr>
<tr class="separator:a956aac44b94a5742b67e721dfe4ee978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fc5a0ccd8949ea39848ea00c5b925f"><td class="memItemLeft" align="right" valign="top"><a id="ac0fc5a0ccd8949ea39848ea00c5b925f"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_connectivity_valid</b> () const =0</td></tr>
<tr class="separator:ac0fc5a0ccd8949ea39848ea00c5b925f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a965a8a24158c4aa8580c57ba09f885f7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a965a8a24158c4aa8580c57ba09f885f7">switch_tuple</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, PrimitiveType type) const =0</td></tr>
<tr class="memdesc:a965a8a24158c4aa8580c57ba09f885f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">switch the orientation of the <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> of the given dimension  <a href="classwmtk_1_1_mesh.html#a965a8a24158c4aa8580c57ba09f885f7">More...</a><br /></td></tr>
<tr class="separator:a965a8a24158c4aa8580c57ba09f885f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed90cad0755b0052b0ca4502e401bcd3"><td class="memItemLeft" align="right" valign="top"><a id="aed90cad0755b0052b0ca4502e401bcd3"></a>
<a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><b>switch_vertex</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const</td></tr>
<tr class="separator:aed90cad0755b0052b0ca4502e401bcd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33805489402321155d4a1f7023faaf3a"><td class="memItemLeft" align="right" valign="top"><a id="a33805489402321155d4a1f7023faaf3a"></a>
<a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><b>switch_edge</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const</td></tr>
<tr class="separator:a33805489402321155d4a1f7023faaf3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca480b3f16ac2aadc9887c42748e239"><td class="memItemLeft" align="right" valign="top"><a id="a6ca480b3f16ac2aadc9887c42748e239"></a>
<a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><b>switch_face</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const</td></tr>
<tr class="separator:a6ca480b3f16ac2aadc9887c42748e239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34a5179470223509cbdae55f2210f05"><td class="memItemLeft" align="right" valign="top"><a id="aa34a5179470223509cbdae55f2210f05"></a>
<a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><b>switch_tetrahedron</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const</td></tr>
<tr class="separator:aa34a5179470223509cbdae55f2210f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8a7b7d592fdbf672f2c6c9653487ea"><td class="memTemplParams" colspan="2"><a id="a7f8a7b7d592fdbf672f2c6c9653487ea"></a>
template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a7f8a7b7d592fdbf672f2c6c9653487ea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>switch_tuples</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, const ContainerType &amp;op_sequence) const</td></tr>
<tr class="separator:a7f8a7b7d592fdbf672f2c6c9653487ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e3f8d60ebf7e64b87f857d38e0965e4"><td class="memItemLeft" align="right" valign="top"><a id="a3e3f8d60ebf7e64b87f857d38e0965e4"></a>
<a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><b>switch_tuples</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, const std::initializer_list&lt; PrimitiveType &gt; &amp;op_sequence) const</td></tr>
<tr class="separator:a3e3f8d60ebf7e64b87f857d38e0965e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072ba17f33381b00b9dec76cb3d986af"><td class="memTemplParams" colspan="2"><a id="a072ba17f33381b00b9dec76cb3d986af"></a>
template&lt;typename ContainerType &gt; </td></tr>
<tr class="memitem:a072ba17f33381b00b9dec76cb3d986af"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>switch_tuples_unsafe</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, const ContainerType &amp;op_sequence) const</td></tr>
<tr class="separator:a072ba17f33381b00b9dec76cb3d986af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c0300690901b7a477823daddd393f1"><td class="memItemLeft" align="right" valign="top"><a id="ad9c0300690901b7a477823daddd393f1"></a>
<a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><b>switch_tuples_unsafe</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, const std::initializer_list&lt; PrimitiveType &gt; &amp;op_sequence) const</td></tr>
<tr class="separator:ad9c0300690901b7a477823daddd393f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f0fba7d6c94d2e545eb671df6af558"><td class="memItemLeft" align="right" valign="top"><a id="a90f0fba7d6c94d2e545eb671df6af558"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_capacities_from_flags</b> ()</td></tr>
<tr class="separator:a90f0fba7d6c94d2e545eb671df6af558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5517017041e409d5b30201602bd9892"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#ab5517017041e409d5b30201602bd9892">capacity</a> (PrimitiveType type) const</td></tr>
<tr class="memdesc:ab5517017041e409d5b30201602bd9892"><td class="mdescLeft">&#160;</td><td class="mdescRight">read in the m_capacities return the upper bound for the number of entities of the given dimension  <a href="classwmtk_1_1_mesh.html#ab5517017041e409d5b30201602bd9892">More...</a><br /></td></tr>
<tr class="separator:ab5517017041e409d5b30201602bd9892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d57041196b23cfa33661c9488c9c4b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a56d57041196b23cfa33661c9488c9c4b">is_ccw</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const =0</td></tr>
<tr class="memdesc:a56d57041196b23cfa33661c9488c9c4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">TODO this needs dimension?  <a href="classwmtk_1_1_mesh.html#a56d57041196b23cfa33661c9488c9c4b">More...</a><br /></td></tr>
<tr class="separator:a56d57041196b23cfa33661c9488c9c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a1834e1446244239f2a8e072e847ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a65a1834e1446244239f2a8e072e847ac">is_boundary</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;codim_1_simplex) const</td></tr>
<tr class="memdesc:a65a1834e1446244239f2a8e072e847ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a simplex of codimension 1 is a boundary simplex  <a href="classwmtk_1_1_mesh.html#a65a1834e1446244239f2a8e072e847ac">More...</a><br /></td></tr>
<tr class="separator:a65a1834e1446244239f2a8e072e847ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4b05ab48bc7990dd619e8e4bf4663e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a7a4b05ab48bc7990dd619e8e4bf4663e">is_boundary</a> (const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;tuple) const</td></tr>
<tr class="memdesc:a7a4b05ab48bc7990dd619e8e4bf4663e"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a simplex lies on a boundary or not  <a href="classwmtk_1_1_mesh.html#a7a4b05ab48bc7990dd619e8e4bf4663e">More...</a><br /></td></tr>
<tr class="separator:a7a4b05ab48bc7990dd619e8e4bf4663e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e15ac67c50a64e6379d851546d71540"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a4e15ac67c50a64e6379d851546d71540">is_boundary</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, PrimitiveType pt) const =0</td></tr>
<tr class="memdesc:a4e15ac67c50a64e6379d851546d71540"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if a simplex (encoded as a tuple/primitive pair) lies on a boundary or not  <a href="classwmtk_1_1_mesh.html#a4e15ac67c50a64e6379d851546d71540">More...</a><br /></td></tr>
<tr class="separator:a4e15ac67c50a64e6379d851546d71540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ce40a666a6539086a6fe629e0b2271"><td class="memItemLeft" align="right" valign="top"><a id="a89ce40a666a6539086a6fe629e0b2271"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_boundary_vertex</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const =0</td></tr>
<tr class="separator:a89ce40a666a6539086a6fe629e0b2271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7d06282d11a4a4fe5c5b25c20bf587c"><td class="memItemLeft" align="right" valign="top"><a id="aa7d06282d11a4a4fe5c5b25c20bf587c"></a>
virtual bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_boundary_edge</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const</td></tr>
<tr class="separator:aa7d06282d11a4a4fe5c5b25c20bf587c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c57c6eb3aa7fa7d201aef6751b4332"><td class="memItemLeft" align="right" valign="top"><a id="a77c57c6eb3aa7fa7d201aef6751b4332"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_hash_valid</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, const ConstAccessor&lt; long &gt; &amp;hash_accessor) const</td></tr>
<tr class="separator:a77c57c6eb3aa7fa7d201aef6751b4332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac776c6e8e9eb2811348bd124caf02622"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#ac776c6e8e9eb2811348bd124caf02622">is_valid</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, ConstAccessor&lt; long &gt; &amp;hash_accessor) const =0</td></tr>
<tr class="memdesc:ac776c6e8e9eb2811348bd124caf02622"><td class="mdescLeft">&#160;</td><td class="mdescRight">check validity of tuple including its hash  <a href="classwmtk_1_1_mesh.html#ac776c6e8e9eb2811348bd124caf02622">More...</a><br /></td></tr>
<tr class="separator:ac776c6e8e9eb2811348bd124caf02622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbb1c54cfd6ec17f4730317ee5fab78d"><td class="memItemLeft" align="right" valign="top"><a id="abbb1c54cfd6ec17f4730317ee5fab78d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_valid_slow</b> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple) const</td></tr>
<tr class="separator:abbb1c54cfd6ec17f4730317ee5fab78d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92d2cdf5a3be21e814e5e6044800f63d"><td class="memItemLeft" align="right" valign="top"><a id="a92d2cdf5a3be21e814e5e6044800f63d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a92d2cdf5a3be21e814e5e6044800f63d">is_multi_mesh_root</a> () const</td></tr>
<tr class="memdesc:a92d2cdf5a3be21e814e5e6044800f63d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return true if this mesh is the root of a multimesh tree <br /></td></tr>
<tr class="separator:a92d2cdf5a3be21e814e5e6044800f63d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac3ec1ebbe00982ddfe70cc710d8f54e"><td class="memItemLeft" align="right" valign="top"><a id="aac3ec1ebbe00982ddfe70cc710d8f54e"></a>
<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#aac3ec1ebbe00982ddfe70cc710d8f54e">get_multi_mesh_root</a> ()</td></tr>
<tr class="memdesc:aac3ec1ebbe00982ddfe70cc710d8f54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a reference to the root of a multimesh tree <br /></td></tr>
<tr class="separator:aac3ec1ebbe00982ddfe70cc710d8f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b636958865ee3c45ad70df7a910775"><td class="memItemLeft" align="right" valign="top"><a id="a30b636958865ee3c45ad70df7a910775"></a>
const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a30b636958865ee3c45ad70df7a910775">get_multi_mesh_root</a> () const</td></tr>
<tr class="memdesc:a30b636958865ee3c45ad70df7a910775"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a const reference to the root of a multimesh tree <br /></td></tr>
<tr class="separator:a30b636958865ee3c45ad70df7a910775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae897154d1c035113188f81c201fa44c6"><td class="memItemLeft" align="right" valign="top"><a id="ae897154d1c035113188f81c201fa44c6"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#ae897154d1c035113188f81c201fa44c6">get_child_meshes</a> () const</td></tr>
<tr class="memdesc:ae897154d1c035113188f81c201fa44c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the direct multimesh child meshes for the current mesh <br /></td></tr>
<tr class="separator:ae897154d1c035113188f81c201fa44c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac19832ab1656a2682b241871e6b3b969"><td class="memItemLeft" align="right" valign="top">std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#ac19832ab1656a2682b241871e6b3b969">absolute_multi_mesh_id</a> () const</td></tr>
<tr class="memdesc:ac19832ab1656a2682b241871e6b3b969"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a unique identifier for this mesh within a single multimesh structure  <a href="classwmtk_1_1_mesh.html#ac19832ab1656a2682b241871e6b3b969">More...</a><br /></td></tr>
<tr class="separator:ac19832ab1656a2682b241871e6b3b969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a333e19ee5ddb037313fa7dbdb0e41771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a333e19ee5ddb037313fa7dbdb0e41771">register_child_mesh</a> (const std::shared_ptr&lt; <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &gt; &amp;child_mesh, const std::vector&lt; std::array&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>, 2 &gt;&gt; &amp;<a class="el" href="classwmtk_1_1_mesh.html#a90d45551368cb9e55efbfda44d356c09">map_tuples</a>)</td></tr>
<tr class="memdesc:a333e19ee5ddb037313fa7dbdb0e41771"><td class="mdescLeft">&#160;</td><td class="mdescRight">register a mesh as the child of this mesh  <a href="classwmtk_1_1_mesh.html#a333e19ee5ddb037313fa7dbdb0e41771">More...</a><br /></td></tr>
<tr class="separator:a333e19ee5ddb037313fa7dbdb0e41771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9bc6bcd75e182825c65e0d4f51d2f73"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#aa9bc6bcd75e182825c65e0d4f51d2f73">map</a> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:aa9bc6bcd75e182825c65e0d4f51d2f73"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a simplex from this mesh to any other mesh  <a href="classwmtk_1_1_mesh.html#aa9bc6bcd75e182825c65e0d4f51d2f73">More...</a><br /></td></tr>
<tr class="separator:aa9bc6bcd75e182825c65e0d4f51d2f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a504b1be94632d44391e3b2c85474bbde"><td class="memItemLeft" align="right" valign="top"><a id="a504b1be94632d44391e3b2c85474bbde"></a>
std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, const std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt; &amp;my_simplices) const</td></tr>
<tr class="separator:a504b1be94632d44391e3b2c85474bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfa5a599297040bbeb64a71ea68dd679"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#abfa5a599297040bbeb64a71ea68dd679">lub_map</a> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:abfa5a599297040bbeb64a71ea68dd679"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a simplex from this mesh to any other mesh using LUB mesh as root  <a href="classwmtk_1_1_mesh.html#abfa5a599297040bbeb64a71ea68dd679">More...</a><br /></td></tr>
<tr class="separator:abfa5a599297040bbeb64a71ea68dd679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cf320b7b7dfe9586eccda1dddcc115c"><td class="memItemLeft" align="right" valign="top"><a id="a6cf320b7b7dfe9586eccda1dddcc115c"></a>
std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lub_map</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, const std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt; &amp;my_simplices) const</td></tr>
<tr class="separator:a6cf320b7b7dfe9586eccda1dddcc115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a673e0ebce43756df3e168fabda9fb3f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a673e0ebce43756df3e168fabda9fb3f2">map_to_parent</a> (const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:a673e0ebce43756df3e168fabda9fb3f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimized map from a simplex from this mesh to its direct parent  <a href="classwmtk_1_1_mesh.html#a673e0ebce43756df3e168fabda9fb3f2">More...</a><br /></td></tr>
<tr class="separator:a673e0ebce43756df3e168fabda9fb3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfcc0100504c8fd429c2c851d53b5f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a2bfcc0100504c8fd429c2c851d53b5f2">map_to_root</a> (const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:a2bfcc0100504c8fd429c2c851d53b5f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a simplex from this mesh to the root mesh  <a href="classwmtk_1_1_mesh.html#a2bfcc0100504c8fd429c2c851d53b5f2">More...</a><br /></td></tr>
<tr class="separator:a2bfcc0100504c8fd429c2c851d53b5f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a718e21d5e107219e06a0141260460ce8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a718e21d5e107219e06a0141260460ce8">map_to_child</a> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;child_mesh, const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:a718e21d5e107219e06a0141260460ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimized map fromsimplex from this mesh to one of its direct children  <a href="classwmtk_1_1_mesh.html#a718e21d5e107219e06a0141260460ce8">More...</a><br /></td></tr>
<tr class="separator:a718e21d5e107219e06a0141260460ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d45551368cb9e55efbfda44d356c09"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a90d45551368cb9e55efbfda44d356c09">map_tuples</a> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:a90d45551368cb9e55efbfda44d356c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a simplex from this mesh to any other mesh  <a href="classwmtk_1_1_mesh.html#a90d45551368cb9e55efbfda44d356c09">More...</a><br /></td></tr>
<tr class="separator:a90d45551368cb9e55efbfda44d356c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d38639fa705c42719431cdffe7885fb"><td class="memItemLeft" align="right" valign="top"><a id="a2d38639fa705c42719431cdffe7885fb"></a>
std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>map_tuples</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, PrimitiveType pt, const std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; &amp;my_simplices) const</td></tr>
<tr class="separator:a2d38639fa705c42719431cdffe7885fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0edcea8b2ad3ebc8fd1df67e1e80cb2f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a0edcea8b2ad3ebc8fd1df67e1e80cb2f">lub_map_tuples</a> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:a0edcea8b2ad3ebc8fd1df67e1e80cb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a simplex from this mesh to any other mesh using LUB mesh as root  <a href="classwmtk_1_1_mesh.html#a0edcea8b2ad3ebc8fd1df67e1e80cb2f">More...</a><br /></td></tr>
<tr class="separator:a0edcea8b2ad3ebc8fd1df67e1e80cb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a200e9023103df15f15802116aa19ec03"><td class="memItemLeft" align="right" valign="top"><a id="a200e9023103df15f15802116aa19ec03"></a>
std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>lub_map_tuples</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other_mesh, PrimitiveType pt, const std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; &amp;my_simplices) const</td></tr>
<tr class="separator:a200e9023103df15f15802116aa19ec03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac57ff3afa07336d8c756617dc29192e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#ac57ff3afa07336d8c756617dc29192e0">map_to_parent_tuple</a> (const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:ac57ff3afa07336d8c756617dc29192e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimized map from a simplex from this mesh to its direct parent  <a href="classwmtk_1_1_mesh.html#ac57ff3afa07336d8c756617dc29192e0">More...</a><br /></td></tr>
<tr class="separator:ac57ff3afa07336d8c756617dc29192e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0527755d4723343b29b6d84259ae6625"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a0527755d4723343b29b6d84259ae6625">map_to_root_tuple</a> (const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:a0527755d4723343b29b6d84259ae6625"><td class="mdescLeft">&#160;</td><td class="mdescRight">maps a simplex from this mesh to the root mesh  <a href="classwmtk_1_1_mesh.html#a0527755d4723343b29b6d84259ae6625">More...</a><br /></td></tr>
<tr class="separator:a0527755d4723343b29b6d84259ae6625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35093efb14e7daddd489ec934c3a0cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#ab35093efb14e7daddd489ec934c3a0cd">map_to_child_tuples</a> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;child_mesh, const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;my_simplex) const</td></tr>
<tr class="memdesc:ab35093efb14e7daddd489ec934c3a0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">optimized map fromsimplex from this mesh to one of its direct children  <a href="classwmtk_1_1_mesh.html#ab35093efb14e7daddd489ec934c3a0cd">More...</a><br /></td></tr>
<tr class="separator:ab35093efb14e7daddd489ec934c3a0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af49f6d60eb21777fbc3e4718930bb8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a1af49f6d60eb21777fbc3e4718930bb8">update_vertex_operation_hashes</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;vertex, Accessor&lt; long &gt; &amp;hash_accessor)</td></tr>
<tr class="memdesc:a1af49f6d60eb21777fbc3e4718930bb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">wrapper function to update hashes (for parent mesh *this and its child meshes) after vertex operations  <a href="classwmtk_1_1_mesh.html#a1af49f6d60eb21777fbc3e4718930bb8">More...</a><br /></td></tr>
<tr class="separator:a1af49f6d60eb21777fbc3e4718930bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dc96ff5c41e087f5b158052f52f1cdf"><td class="memItemLeft" align="right" valign="top">virtual long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a4dc96ff5c41e087f5b158052f52f1cdf">id</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, PrimitiveType type) const =0</td></tr>
<tr class="memdesc:a4dc96ff5c41e087f5b158052f52f1cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the global id of the <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> of the given dimension  <a href="classwmtk_1_1_mesh.html#a4dc96ff5c41e087f5b158052f52f1cdf">More...</a><br /></td></tr>
<tr class="separator:a4dc96ff5c41e087f5b158052f52f1cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c9401651a324ef261b293fd55513fc"><td class="memItemLeft" align="right" valign="top"><a id="ae0c9401651a324ef261b293fd55513fc"></a>
long&#160;</td><td class="memItemRight" valign="bottom"><b>id</b> (const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;s) const</td></tr>
<tr class="separator:ae0c9401651a324ef261b293fd55513fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f3d66afdf2485207f36a805281534c"><td class="memItemLeft" align="right" valign="top"><a id="a79f3d66afdf2485207f36a805281534c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_capacities</b> (std::vector&lt; long &gt; capacities)</td></tr>
<tr class="separator:a79f3d66afdf2485207f36a805281534c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4488512243e58f854f5444946cbe43de"><td class="memItemLeft" align="right" valign="top"><a id="a4488512243e58f854f5444946cbe43de"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve_more_attributes</b> (PrimitiveType type, long size)</td></tr>
<tr class="separator:a4488512243e58f854f5444946cbe43de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24203a7e22fc1f39b76b684345e1917e"><td class="memItemLeft" align="right" valign="top"><a id="a24203a7e22fc1f39b76b684345e1917e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve_more_attributes</b> (const std::vector&lt; long &gt; &amp;sizes)</td></tr>
<tr class="separator:a24203a7e22fc1f39b76b684345e1917e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classwmtk_1_1utils_1_1_merkle_tree_interior_node"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classwmtk_1_1utils_1_1_merkle_tree_interior_node')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classwmtk_1_1utils_1_1_merkle_tree_interior_node.html">wmtk::utils::MerkleTreeInteriorNode</a></td></tr>
<tr class="memitem:a93791c16f3a59b614619e6481c2804dd inherit pub_methods_classwmtk_1_1utils_1_1_merkle_tree_interior_node"><td class="memItemLeft" align="right" valign="top"><a id="a93791c16f3a59b614619e6481c2804dd"></a>
std::map&lt; std::string, std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>child_hashes</b> () const override</td></tr>
<tr class="separator:a93791c16f3a59b614619e6481c2804dd inherit pub_methods_classwmtk_1_1utils_1_1_merkle_tree_interior_node"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classwmtk_1_1utils_1_1_hashable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classwmtk_1_1utils_1_1_hashable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classwmtk_1_1utils_1_1_hashable.html">wmtk::utils::Hashable</a></td></tr>
<tr class="memitem:a669437dfe34d7453f103f4da905bd9b2 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memItemLeft" align="right" valign="top"><a id="a669437dfe34d7453f103f4da905bd9b2"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Hashable</b> (const <a class="el" href="classwmtk_1_1utils_1_1_hashable.html">Hashable</a> &amp;)</td></tr>
<tr class="separator:a669437dfe34d7453f103f4da905bd9b2 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198b072d861d3a4284429ac75547897f inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memItemLeft" align="right" valign="top"><a id="a198b072d861d3a4284429ac75547897f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Hashable</b> (<a class="el" href="classwmtk_1_1utils_1_1_hashable.html">Hashable</a> &amp;&amp;)</td></tr>
<tr class="separator:a198b072d861d3a4284429ac75547897f inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9453a260cca3b4bc3a8c6157e7daf335 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memItemLeft" align="right" valign="top"><a id="a9453a260cca3b4bc3a8c6157e7daf335"></a>
<a class="el" href="classwmtk_1_1utils_1_1_hashable.html">Hashable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classwmtk_1_1utils_1_1_hashable.html">Hashable</a> &amp;)</td></tr>
<tr class="separator:a9453a260cca3b4bc3a8c6157e7daf335 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266fde09c2c4f4a648c0bb553999c5a2 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memItemLeft" align="right" valign="top"><a id="a266fde09c2c4f4a648c0bb553999c5a2"></a>
<a class="el" href="classwmtk_1_1utils_1_1_hashable.html">Hashable</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classwmtk_1_1utils_1_1_hashable.html">Hashable</a> &amp;&amp;)</td></tr>
<tr class="separator:a266fde09c2c4f4a648c0bb553999c5a2 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842b5754b2d7aca0fe6e4fb3c98a3644 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memItemLeft" align="right" valign="top"><a id="a842b5754b2d7aca0fe6e4fb3c98a3644"></a>
virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><b>hash</b> () const</td></tr>
<tr class="separator:a842b5754b2d7aca0fe6e4fb3c98a3644 inherit pub_methods_classwmtk_1_1utils_1_1_hashable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a77b60f43aa3953d91b06701c56e8c764"><td class="memTemplParams" colspan="2"><a id="a77b60f43aa3953d91b06701c56e8c764"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a77b60f43aa3953d91b06701c56e8c764"><td class="memTemplItemLeft" align="right" valign="top">static auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_access</b> (<a class="el" href="classwmtk_1_1attribute_1_1_mutable_accessor.html">attribute::MutableAccessor</a>&lt; T &gt; &amp;attr)</td></tr>
<tr class="separator:a77b60f43aa3953d91b06701c56e8c764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4bb1a52141263e54adc983bc9e7da0"><td class="memTemplParams" colspan="2"><a id="a4e4bb1a52141263e54adc983bc9e7da0"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a4e4bb1a52141263e54adc983bc9e7da0"><td class="memTemplItemLeft" align="right" valign="top">static auto &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get_index_access</b> (const <a class="el" href="classwmtk_1_1attribute_1_1_const_accessor.html">attribute::ConstAccessor</a>&lt; T &gt; &amp;attr)</td></tr>
<tr class="separator:a4e4bb1a52141263e54adc983bc9e7da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8da8bcf73599ceb286598d82dd38f9f9"><td class="memItemLeft" align="right" valign="top"><a id="a8da8bcf73599ceb286598d82dd38f9f9"></a>
Accessor&lt; char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_flag_accessor</b> (PrimitiveType type)</td></tr>
<tr class="separator:a8da8bcf73599ceb286598d82dd38f9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a405efa1c903e83a5516516c0a1bd75a7"><td class="memItemLeft" align="right" valign="top"><a id="a405efa1c903e83a5516516c0a1bd75a7"></a>
Accessor&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>get_cell_hash_accessor</b> ()</td></tr>
<tr class="separator:a405efa1c903e83a5516516c0a1bd75a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5372ed754550f3b86f14dd12dd5197c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a5372ed754550f3b86f14dd12dd5197c7">update_cell_hash</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;cell, Accessor&lt; long &gt; &amp;hash_accessor)</td></tr>
<tr class="memdesc:a5372ed754550f3b86f14dd12dd5197c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">update hash in given cell  <a href="classwmtk_1_1_mesh.html#a5372ed754550f3b86f14dd12dd5197c7">More...</a><br /></td></tr>
<tr class="separator:a5372ed754550f3b86f14dd12dd5197c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd77a22e8fcbd11e52678e0c589bdde8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#afd77a22e8fcbd11e52678e0c589bdde8">update_cell_hashes</a> (const std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; &amp;cells, Accessor&lt; long &gt; &amp;hash_accessor)</td></tr>
<tr class="memdesc:afd77a22e8fcbd11e52678e0c589bdde8"><td class="mdescLeft">&#160;</td><td class="mdescRight">update hashes in given cells  <a href="classwmtk_1_1_mesh.html#afd77a22e8fcbd11e52678e0c589bdde8">More...</a><br /></td></tr>
<tr class="separator:afd77a22e8fcbd11e52678e0c589bdde8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcadcbeb0bcbd4a82905620ec4c3a20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a4bcadcbeb0bcbd4a82905620ec4c3a20">update_cell_hash</a> (const long cell_index, Accessor&lt; long &gt; &amp;hash_accessor)</td></tr>
<tr class="memdesc:a4bcadcbeb0bcbd4a82905620ec4c3a20"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as <code>update_cell_hashes</code> but slow because it creates a new accessor  <a href="classwmtk_1_1_mesh.html#a4bcadcbeb0bcbd4a82905620ec4c3a20">More...</a><br /></td></tr>
<tr class="separator:a4bcadcbeb0bcbd4a82905620ec4c3a20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a823ea6b42a81227ca35a7aa5ac760cea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a823ea6b42a81227ca35a7aa5ac760cea">update_cell_hashes</a> (const std::vector&lt; long &gt; &amp;cell_indices, Accessor&lt; long &gt; &amp;hash_accessor)</td></tr>
<tr class="memdesc:a823ea6b42a81227ca35a7aa5ac760cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">update hashes in given cells  <a href="classwmtk_1_1_mesh.html#a823ea6b42a81227ca35a7aa5ac760cea">More...</a><br /></td></tr>
<tr class="separator:a823ea6b42a81227ca35a7aa5ac760cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10dc60988327a1f0ace86051df4f3e65"><td class="memItemLeft" align="right" valign="top"><a id="a10dc60988327a1f0ace86051df4f3e65"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>update_cell_hashes_slow</b> (const std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; &amp;cells)</td></tr>
<tr class="separator:a10dc60988327a1f0ace86051df4f3e65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f0cd5ad21e7d1ce9b132c5cfdc455f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a14f0cd5ad21e7d1ce9b132c5cfdc455f">resurrect_tuple</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple, const ConstAccessor&lt; long &gt; &amp;hash_accessor) const</td></tr>
<tr class="memdesc:a14f0cd5ad21e7d1ce9b132c5cfdc455f"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the same tuple but with updated hash  <a href="classwmtk_1_1_mesh.html#a14f0cd5ad21e7d1ce9b132c5cfdc455f">More...</a><br /></td></tr>
<tr class="separator:a14f0cd5ad21e7d1ce9b132c5cfdc455f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb2f7ff22ab4aab437168c5962d6266"><td class="memItemLeft" align="right" valign="top"><a id="a3bb2f7ff22ab4aab437168c5962d6266"></a>
<a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a3bb2f7ff22ab4aab437168c5962d6266">resurrect_tuple_slow</a> (const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;tuple)</td></tr>
<tr class="memdesc:a3bb2f7ff22ab4aab437168c5962d6266"><td class="mdescLeft">&#160;</td><td class="mdescRight">same as <code>resurrect_tuple</code> but slow because it creates a new accessor <br /></td></tr>
<tr class="separator:a3bb2f7ff22ab4aab437168c5962d6266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4bf728721a8d45609419457c43314b"><td class="memItemLeft" align="right" valign="top"><a id="aef4bf728721a8d45609419457c43314b"></a>
std::vector&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>request_simplex_indices</b> (PrimitiveType type, long count)</td></tr>
<tr class="separator:aef4bf728721a8d45609419457c43314b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dfb62b5d5aab1340e03fca5049951bf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a1dfb62b5d5aab1340e03fca5049951bf">tuple_from_id</a> (const PrimitiveType type, const long gid) const =0</td></tr>
<tr class="memdesc:a1dfb62b5d5aab1340e03fca5049951bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal function that returns the tuple of requested type, and has the global index cid  <a href="classwmtk_1_1_mesh.html#a1dfb62b5d5aab1340e03fca5049951bf">More...</a><br /></td></tr>
<tr class="separator:a1dfb62b5d5aab1340e03fca5049951bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632239541ea92770466e8840c9088c96"><td class="memItemLeft" align="right" valign="top"><a id="a632239541ea92770466e8840c9088c96"></a>
std::vector&lt; std::vector&lt; long &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>simplices_to_gids</b> (const std::vector&lt; std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt;&gt; &amp;simplices) const</td></tr>
<tr class="separator:a632239541ea92770466e8840c9088c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a326d46e931aebe5707255618d4a0b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a9a326d46e931aebe5707255618d4a0b0">reserve_attributes_to_fit</a> ()</td></tr>
<tr class="memdesc:a9a326d46e931aebe5707255618d4a0b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserve space for all attributes data types for all dimensional simplices  <a href="classwmtk_1_1_mesh.html#a9a326d46e931aebe5707255618d4a0b0">More...</a><br /></td></tr>
<tr class="separator:a9a326d46e931aebe5707255618d4a0b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c163a557c3d14751216e2f82ea5b921"><td class="memItemLeft" align="right" valign="top"><a id="a5c163a557c3d14751216e2f82ea5b921"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve_attributes</b> (PrimitiveType type, long size)</td></tr>
<tr class="separator:a5c163a557c3d14751216e2f82ea5b921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c95867d9934ca7081f4516378e26f6"><td class="memItemLeft" align="right" valign="top"><a id="ad1c95867d9934ca7081f4516378e26f6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>reserve_attributes</b> (long dimension, long size)</td></tr>
<tr class="separator:ad1c95867d9934ca7081f4516378e26f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bc202cb5a2deadfce19a0c733a1a498"><td class="memItemLeft" align="right" valign="top"><a id="a9bc202cb5a2deadfce19a0c733a1a498"></a>
<a class="el" href="classwmtk_1_1attribute_1_1_attribute_scope_handle.html">attribute::AttributeScopeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>create_single_mesh_scope</b> ()</td></tr>
<tr class="separator:a9bc202cb5a2deadfce19a0c733a1a498"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af64daf6aaf6ffd14ce791695d6428cbc"><td class="memItemLeft" align="right" valign="top"><a id="af64daf6aaf6ffd14ce791695d6428cbc"></a>
<a class="el" href="classwmtk_1_1attribute_1_1_attribute_manager.html">attribute::AttributeManager</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_attribute_manager</b></td></tr>
<tr class="separator:af64daf6aaf6ffd14ce791695d6428cbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67ee2baeee30f785211e781d4b814eb"><td class="memItemLeft" align="right" valign="top"><a id="af67ee2baeee30f785211e781d4b814eb"></a>
<a class="el" href="classwmtk_1_1_multi_mesh_manager.html">MultiMeshManager</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_multi_mesh_manager</b></td></tr>
<tr class="separator:af67ee2baeee30f785211e781d4b814eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea9cce360c1288b4c00856b555d623b"><td class="memItemLeft" align="right" valign="top"><a id="afea9cce360c1288b4c00856b555d623b"></a>
std::vector&lt; attribute::MeshAttributeHandleVariant &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_attributes</b></td></tr>
<tr class="separator:afea9cce360c1288b4c00856b555d623b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad054c074d4776010002321117ec459e8"><td class="memItemLeft" align="right" valign="top"><a id="ad054c074d4776010002321117ec459e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_from_same_multi_mesh_structure</b> (const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;other) const</td></tr>
<tr class="separator:ad054c074d4776010002321117ec459e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a893e47f5da1a44ca19eb2b1665506cce"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a893e47f5da1a44ca19eb2b1665506cce">get_all</a> (PrimitiveType type, const bool include_deleted) const</td></tr>
<tr class="separator:a893e47f5da1a44ca19eb2b1665506cce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a41ec501e2bd3fdb51fcc7ab7615ffb30"><td class="memItemLeft" align="right" valign="top"><a id="a41ec501e2bd3fdb51fcc7ab7615ffb30"></a>
std::vector&lt; <a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwmtk_1_1_mesh.html#a41ec501e2bd3fdb51fcc7ab7615ffb30">m_flag_handles</a></td></tr>
<tr class="memdesc:a41ec501e2bd3fdb51fcc7ab7615ffb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">0x1 == true = simplex is active (simplex exists) all flag default to 0 <br /></td></tr>
<tr class="separator:a41ec501e2bd3fdb51fcc7ab7615ffb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa14fca67795f554b579ebe4da1eba21c"><td class="memItemLeft" align="right" valign="top"><a id="aa14fca67795f554b579ebe4da1eba21c"></a>
<a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt; long &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_cell_hash_handle</b></td></tr>
<tr class="separator:aa14fca67795f554b579ebe4da1eba21c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a453bfa4c9f420534b768690a9aaf0c5f"><td class="memTemplParams" colspan="2"><a id="a453bfa4c9f420534b768690a9aaf0c5f"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a453bfa4c9f420534b768690a9aaf0c5f"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>attribute::AccessorBase</b></td></tr>
<tr class="separator:a453bfa4c9f420534b768690a9aaf0c5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04adec229d19f4fb31dab0b562f79b74"><td class="memTemplParams" colspan="2"><a id="a04adec229d19f4fb31dab0b562f79b74"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a04adec229d19f4fb31dab0b562f79b74"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>attribute::TupleAccessor</b></td></tr>
<tr class="separator:a04adec229d19f4fb31dab0b562f79b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae84114ba2421638e069577835b92ca8a"><td class="memItemLeft" align="right" valign="top"><a id="ae84114ba2421638e069577835b92ca8a"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>io::ParaviewWriter</b></td></tr>
<tr class="separator:ae84114ba2421638e069577835b92ca8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858d08e8281a6357dbfd930adfa16583"><td class="memItemLeft" align="right" valign="top"><a id="a858d08e8281a6357dbfd930adfa16583"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>HDF5Reader</b></td></tr>
<tr class="separator:a858d08e8281a6357dbfd930adfa16583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c20f1914db5c8e09ced34adb3e1902d"><td class="memItemLeft" align="right" valign="top"><a id="a9c20f1914db5c8e09ced34adb3e1902d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MultiMeshManager</b></td></tr>
<tr class="separator:a9c20f1914db5c8e09ced34adb3e1902d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb29934d46621cdb44e5f6f3ab2e84e"><td class="memItemLeft" align="right" valign="top"><a id="adcb29934d46621cdb44e5f6f3ab2e84e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>attribute::AttributeManager</b></td></tr>
<tr class="separator:adcb29934d46621cdb44e5f6f3ab2e84e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa719cbea5d32f6cc40db26f5427c9f40"><td class="memTemplParams" colspan="2"><a id="aa719cbea5d32f6cc40db26f5427c9f40"></a>
template&lt;long cell_dimension, typename NodeFunctor &gt; </td></tr>
<tr class="memitem:aa719cbea5d32f6cc40db26f5427c9f40"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multimesh::MultiMeshSimplexVisitor</b></td></tr>
<tr class="separator:aa719cbea5d32f6cc40db26f5427c9f40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a13c0ea4d5c720e07247ab082f535c"><td class="memTemplParams" colspan="2"><a id="ad9a13c0ea4d5c720e07247ab082f535c"></a>
template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:ad9a13c0ea4d5c720e07247ab082f535c"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multimesh::MultiMeshSimplexVisitorExecutor</b></td></tr>
<tr class="separator:ad9a13c0ea4d5c720e07247ab082f535c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7fc43432accd107d1b9de25240a04bd"><td class="memTemplParams" colspan="2"><a id="af7fc43432accd107d1b9de25240a04bd"></a>
template&lt;typename NodeFunctor &gt; </td></tr>
<tr class="memitem:af7fc43432accd107d1b9de25240a04bd"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multimesh::MultiMeshVisitor</b></td></tr>
<tr class="separator:af7fc43432accd107d1b9de25240a04bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19a15fe846f3505d90346baf731ff11"><td class="memTemplParams" colspan="2"><a id="ab19a15fe846f3505d90346baf731ff11"></a>
template&lt;typename Visitor &gt; </td></tr>
<tr class="memitem:ab19a15fe846f3505d90346baf731ff11"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>multimesh::MultiMeshVisitorExecutor</b></td></tr>
<tr class="separator:ab19a15fe846f3505d90346baf731ff11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294d4ff3ee7f5edf69b88b2c42f8c6cb"><td class="memItemLeft" align="right" valign="top"><a id="a294d4ff3ee7f5edf69b88b2c42f8c6cb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>multimesh::attribute::AttributeScopeHandle</b></td></tr>
<tr class="separator:a294d4ff3ee7f5edf69b88b2c42f8c6cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29529c7437c9adf52b6959bbd45415e"><td class="memItemLeft" align="right" valign="top"><a id="ab29529c7437c9adf52b6959bbd45415e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>multimesh::utils::internal::TupleTag</b></td></tr>
<tr class="separator:ab29529c7437c9adf52b6959bbd45415e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb76cb4220d4955c139bd9a3a8852f12"><td class="memItemLeft" align="right" valign="top"><a id="adb76cb4220d4955c139bd9a3a8852f12"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>operations::utils::UpdateEdgeOperationMultiMeshMapFunctor</b></td></tr>
<tr class="separator:adb76cb4220d4955c139bd9a3a8852f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e92d16749ee808899eedf5e90ce32e"><td class="memItemLeft" align="right" valign="top"><a id="a07e92d16749ee808899eedf5e90ce32e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>simplex::RawSimplex</b></td></tr>
<tr class="separator:a07e92d16749ee808899eedf5e90ce32e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f7bf7f8aa17013b046f9af6e776ca4"><td class="memItemLeft" align="right" valign="top"><a id="ae7f7bf7f8aa17013b046f9af6e776ca4"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>simplex::utils::SimplexComparisons</b></td></tr>
<tr class="separator:ae7f7bf7f8aa17013b046f9af6e776ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00aedffbf97f4e854d05099801960a6"><td class="memItemLeft" align="right" valign="top"><a id="ae00aedffbf97f4e854d05099801960a6"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>operations::Operation</b></td></tr>
<tr class="separator:ae00aedffbf97f4e854d05099801960a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155eafac5bbedd0f505948bc2de5949e"><td class="memItemLeft" align="right" valign="top"><a id="a155eafac5bbedd0f505948bc2de5949e"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>operations::EdgeCollapse</b></td></tr>
<tr class="separator:a155eafac5bbedd0f505948bc2de5949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d9f2854936ca9367676cf9108178d7"><td class="memItemLeft" align="right" valign="top"><a id="a00d9f2854936ca9367676cf9108178d7"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>operations::EdgeSplit</b></td></tr>
<tr class="separator:a00d9f2854936ca9367676cf9108178d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1264fe05d4c13c1223630b68e1028cbb"><td class="memItemLeft" align="right" valign="top"><a id="a1264fe05d4c13c1223630b68e1028cbb"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>operations::EdgeOperationData</b></td></tr>
<tr class="separator:a1264fe05d4c13c1223630b68e1028cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c471b248f0d3c58dd8b6957dd0a661"><td class="memItemLeft" align="right" valign="top"><a id="a83c471b248f0d3c58dd8b6957dd0a661"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operations::utils::update_vertex_operation_multimesh_map_hash</b> (<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;m, const <a class="el" href="classwmtk_1_1_simplicial_complex.html">SimplicialComplex</a> &amp;vertex_closed_star, Accessor&lt; long &gt; &amp;parent_hash_accessor)</td></tr>
<tr class="separator:a83c471b248f0d3c58dd8b6957dd0a661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba4ea36dcfe2063d60203ec20c1e42b"><td class="memItemLeft" align="right" valign="top"><a id="a0ba4ea36dcfe2063d60203ec20c1e42b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>operations::utils::update_vertex_operation_hashes</b> (<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;m, const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;vertex, Accessor&lt; long &gt; &amp;hash_accessor)</td></tr>
<tr class="separator:a0ba4ea36dcfe2063d60203ec20c1e42b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4898d4a131b9de48094590427021a3d4"><td class="memItemLeft" align="right" valign="top"><a id="a4898d4a131b9de48094590427021a3d4"></a>
std::shared_ptr&lt; <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>multimesh::utils::extract_and_register_child_mesh_from_tag_handle</b> (<a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;m, const <a class="el" href="classwmtk_1_1attribute_1_1_mesh_attribute_handle.html">MeshAttributeHandle</a>&lt; long &gt; &amp;tag_handle, const long tag_value)</td></tr>
<tr class="separator:a4898d4a131b9de48094590427021a3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac19832ab1656a2682b241871e6b3b969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac19832ab1656a2682b241871e6b3b969">&#9670;&nbsp;</a></span>absolute_multi_mesh_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; long &gt; wmtk::Mesh::absolute_multi_mesh_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns a unique identifier for this mesh within a single multimesh structure </p>
<p>Typically the root node should have an empty vector as the id {} Its first child will have an id of {0} Its second child will have an id of {1} Its first child's second child will have an id of {0,1} </p>

</div>
</div>
<a id="ab5517017041e409d5b30201602bd9892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5517017041e409d5b30201602bd9892">&#9670;&nbsp;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long wmtk::Mesh::capacity </td>
          <td>(</td>
          <td class="paramtype">PrimitiveType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read in the m_capacities return the upper bound for the number of entities of the given dimension </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int </dd></dl>

</div>
</div>
<a id="a9bf9ba1745bd07a33dcfa8b679e33290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf9ba1745bd07a33dcfa8b679e33290">&#9670;&nbsp;</a></span>connectivity_attributes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::vector&lt;<a class="el" href="classwmtk_1_1attribute_1_1_typed_attribute_handle.html">TypedAttributeHandle</a>&lt;long&gt; &gt; &gt; wmtk::Mesh::connectivity_attributes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of vectors of attribute handles. The first index denotes the type of simplex pointed by the attribute (i.e. the index type). As an example, the FV relationship points to vertices so it should be returned in the slot [0]. </p>

<p>Implemented in <a class="el" href="classwmtk_1_1_tri_mesh.html#aa308eb425611809525d04176d1d64f48">wmtk::TriMesh</a>, <a class="el" href="classwmtk_1_1_tet_mesh.html#a5da3dd1407e0107a72815fc11d4f61dd">wmtk::TetMesh</a>, <a class="el" href="classwmtk_1_1_point_mesh.html#a61e779876c0e3eb7d8a5ab8ae4395f81">wmtk::PointMesh</a>, and <a class="el" href="classwmtk_1_1_edge_mesh.html#a2789b1874ad66d79b75677129eba7bf9">wmtk::EdgeMesh</a>.</p>

</div>
</div>
<a id="a0e8ede2e60df546bb323fc47e2338c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e8ede2e60df546bb323fc47e2338c25">&#9670;&nbsp;</a></span>consolidate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::vector&lt; std::vector&lt; long &gt; &gt;, std::vector&lt; std::vector&lt; long &gt; &gt; &gt; wmtk::Mesh::consolidate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Consolidate the attributes, moving all valid simplexes at the beginning of the corresponding vector </p>

</div>
</div>
<a id="a6d2a546c8f661bf6386cf845a1693d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d2a546c8f661bf6386cf845a1693d2f">&#9670;&nbsp;</a></span>get_all() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; wmtk::Mesh::get_all </td>
          <td>(</td>
          <td class="paramtype">PrimitiveType&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate a vector of Tuples from global vertex/edge/triangle/tetrahedron index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of tuple, can be vertex/edge/triangle/tetrahedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of Tuples referring to each type </dd></dl>

</div>
</div>
<a id="a893e47f5da1a44ca19eb2b1665506cce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a893e47f5da1a44ca19eb2b1665506cce">&#9670;&nbsp;</a></span>get_all() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; wmtk::Mesh::get_all </td>
          <td>(</td>
          <td class="paramtype">PrimitiveType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>include_deleted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate a vector of Tuples from global vertex/edge/triangle/tetrahedron index </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>the type of tuple, can be vertex/edge/triangle/tetrahedron </td></tr>
    <tr><td class="paramname">include_deleted</td><td>if true returns also the deleted tuples (default false) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of Tuples referring to each type </dd></dl>

</div>
</div>
<a id="a4dc96ff5c41e087f5b158052f52f1cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4dc96ff5c41e087f5b158052f52f1cdf">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual long wmtk::Mesh::id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrimitiveType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the global id of the <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> of the given dimension </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">type</td><td>d-0 -&gt; vertex d-1 -&gt; edge d-2 -&gt; face d-3 -&gt; tetrahedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>long id of the entity </dd></dl>

<p>Implemented in <a class="el" href="classwmtk_1_1_tri_mesh.html#ab37b9e594ec6817b12f278cac26e5818">wmtk::TriMesh</a>, <a class="el" href="classwmtk_1_1_tet_mesh.html#a3d7be07a6583376f0d57323deb852793">wmtk::TetMesh</a>, <a class="el" href="classwmtk_1_1_point_mesh.html#a7c2028da4a2dab1c86958d8e6fd10db9">wmtk::PointMesh</a>, and <a class="el" href="classwmtk_1_1_edge_mesh.html#abc0f3324c6a42dd3c1966dadf5f34cf0">wmtk::EdgeMesh</a>.</p>

</div>
</div>
<a id="a7a4b05ab48bc7990dd619e8e4bf4663e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4b05ab48bc7990dd619e8e4bf4663e">&#9670;&nbsp;</a></span>is_boundary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wmtk::Mesh::is_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if a simplex lies on a boundary or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this simplex lies on the boundary of the mesh </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a65a1834e1446244239f2a8e072e847ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a1834e1446244239f2a8e072e847ac">&#9670;&nbsp;</a></span>is_boundary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool wmtk::Mesh::is_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>codim_1_simplex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if a simplex of codimension 1 is a boundary simplex </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all tuple simplices besides the cell are on the boundary </dd>
<dd>
false otherwise </dd></dl>

</div>
</div>
<a id="a4e15ac67c50a64e6379d851546d71540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e15ac67c50a64e6379d851546d71540">&#9670;&nbsp;</a></span>is_boundary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool wmtk::Mesh::is_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrimitiveType&#160;</td>
          <td class="paramname"><em>pt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check if a simplex (encoded as a tuple/primitive pair) lies on a boundary or not </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">simplex</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if this simplex lies on the boundary of the mesh </dd>
<dd>
false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classwmtk_1_1_edge_mesh.html#ad5f1d56e51304c8acceb57841e4ea76f">wmtk::EdgeMesh</a>, <a class="el" href="classwmtk_1_1_tri_mesh.html#a23eaac65ebaa21efc0294919428c692a">wmtk::TriMesh</a>, <a class="el" href="classwmtk_1_1_tet_mesh.html#a53cb59c89b699db968e8529db8f22167">wmtk::TetMesh</a>, and <a class="el" href="classwmtk_1_1_point_mesh.html#a46a26d10ef71c6915694787278016d41">wmtk::PointMesh</a>.</p>

</div>
</div>
<a id="a56d57041196b23cfa33661c9488c9c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d57041196b23cfa33661c9488c9c4b">&#9670;&nbsp;</a></span>is_ccw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool wmtk::Mesh::is_ccw </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>TODO this needs dimension? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> is oriented counter-clockwise </dd>
<dd>
false </dd></dl>

<p>Implemented in <a class="el" href="classwmtk_1_1_tri_mesh.html#ab5a7b693c52023d7277e8c00f975911d">wmtk::TriMesh</a>, <a class="el" href="classwmtk_1_1_tet_mesh.html#a0db03200a449485005c9c1c69c80a4fa">wmtk::TetMesh</a>, <a class="el" href="classwmtk_1_1_point_mesh.html#ad29ad1b43dcf91de19c7389a587932aa">wmtk::PointMesh</a>, and <a class="el" href="classwmtk_1_1_edge_mesh.html#a83db0c93833dacdfb169807d8ba4b6ca">wmtk::EdgeMesh</a>.</p>

</div>
</div>
<a id="ac776c6e8e9eb2811348bd124caf02622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac776c6e8e9eb2811348bd124caf02622">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool wmtk::Mesh::is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ConstAccessor&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>hash_accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>check validity of tuple including its hash </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>the tuple to be checked </td></tr>
    <tr><td class="paramname">type</td><td>only the top cell dimension, other validity follows with assumption of manifoldness. 2-&gt;triangle, 3-&gt;tetrahedron </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if is valid </dd>
<dd>
false </dd></dl>

<p>Implemented in <a class="el" href="classwmtk_1_1_tri_mesh.html#aa9c74c3f58698039de0d0eaea5150d6e">wmtk::TriMesh</a>, <a class="el" href="classwmtk_1_1_tet_mesh.html#a6c510e698bcea0cc7a084ec294750b67">wmtk::TetMesh</a>, <a class="el" href="classwmtk_1_1_point_mesh.html#a5e803a1178f92b18e6d0e51018beaf49">wmtk::PointMesh</a>, and <a class="el" href="classwmtk_1_1_edge_mesh.html#a547de6dc5e1e6c873e6967c56768ef13">wmtk::EdgeMesh</a>.</p>

</div>
</div>
<a id="abfa5a599297040bbeb64a71ea68dd679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfa5a599297040bbeb64a71ea68dd679">&#9670;&nbsp;</a></span>lub_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt; wmtk::Mesh::lub_map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>other_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps a simplex from this mesh to any other mesh using LUB mesh as root </p>
<p>Satisfies the same properties of standard map, but uses a the LUB as the root</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh a simplex should be mapped to </td></tr>
    <tr><td class="paramname">simplex</td><td>the simplex being mapped to the child mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>every simplex that corresponds to this simplex </dd></dl>

</div>
</div>
<a id="a0edcea8b2ad3ebc8fd1df67e1e80cb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0edcea8b2ad3ebc8fd1df67e1e80cb2f">&#9670;&nbsp;</a></span>lub_map_tuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; wmtk::Mesh::lub_map_tuples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>other_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps a simplex from this mesh to any other mesh using LUB mesh as root </p>
<p>Satisfies the same properties of standard map_tuples, but uses a the LUB as the root</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh a simplex should be mapped to </td></tr>
    <tr><td class="paramname">simplex</td><td>the simplex being mapped to the child mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>every simplex that corresponds to this simplex </dd></dl>

</div>
</div>
<a id="aa9bc6bcd75e182825c65e0d4f51d2f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9bc6bcd75e182825c65e0d4f51d2f73">&#9670;&nbsp;</a></span>map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt; wmtk::Mesh::map </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>other_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps a simplex from this mesh to any other mesh </p>
<p>Generic interface for mapping between two arbitrary meshes in a multi-mesh structure. Note that this finds ALL versions of a simplex, potentially crossing over topological features above the pairs of simplices being mapped. For instance, if we map a trimesh seam edge to itself using this interface it will find the edge on the other side of the seam. If more granular mappings are required consider manually navigating the tree with map_to_parent and map_to_child, which of course require a more particular understanding on how a simplex is mapped. Throws if two meshes are not part of the same multi-mesh structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>the mesh a simplex should be mapped to </td></tr>
    <tr><td class="paramname">simplex</td><td>the simplex being mapped to the child mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>every simplex that corresponds to this simplex </dd></dl>

</div>
</div>
<a id="a718e21d5e107219e06a0141260460ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a718e21d5e107219e06a0141260460ce8">&#9670;&nbsp;</a></span>map_to_child()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &gt; wmtk::Mesh::map_to_child </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>child_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>optimized map fromsimplex from this mesh to one of its direct children </p>
<p>Cannot be used outside of applications with guaranteed multi-mesh structures</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_mesh</td><td>the simplex shoudl be mapped to </td></tr>
    <tr><td class="paramname">my_simplex</td><td>the simplex being mapped to the child mesh </td></tr>
    <tr><td class="paramname">the</td><td>set of child mesh's simplices that are equivalent to the input simplex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab35093efb14e7daddd489ec934c3a0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35093efb14e7daddd489ec934c3a0cd">&#9670;&nbsp;</a></span>map_to_child_tuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; wmtk::Mesh::map_to_child_tuples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>child_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>optimized map fromsimplex from this mesh to one of its direct children </p>
<p>Cannot be used outside of applications with guaranteed multi-mesh structures</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child</td><td>mesh the simplex shoudl be mapped to </td></tr>
    <tr><td class="paramname">child_mesh</td><td>the simplex being mapped to the child mesh </td></tr>
    <tr><td class="paramname">my_simplex</td><td>the set of child mesh's simplices that are equivalent to the input simplex, without the dimension encoded </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a673e0ebce43756df3e168fabda9fb3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a673e0ebce43756df3e168fabda9fb3f2">&#9670;&nbsp;</a></span>map_to_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> wmtk::Mesh::map_to_parent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>optimized map from a simplex from this mesh to its direct parent </p>
<p>Maps a simplex to its direct parent in the multi-mesh structure. Cannot be used outside of applications with guaranteed multi-mesh structures</p>
<p>throws if this is the root</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_simplex</td><td>the simplex being mapped to the parent mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unique parent mesh's simplex that is parent to the input one </dd></dl>

</div>
</div>
<a id="ac57ff3afa07336d8c756617dc29192e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac57ff3afa07336d8c756617dc29192e0">&#9670;&nbsp;</a></span>map_to_parent_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> wmtk::Mesh::map_to_parent_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>optimized map from a simplex from this mesh to its direct parent </p>
<p>Maps a simplex to its direct parent in the multi-mesh structure. Can only be used in applications with guaranteed multi-mesh structures</p>
<p>throws if this is the root</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_simplex</td><td>the simplex being mapped to the parent mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unique parent mesh's simplex that is parent to the input one, without the dimension encoded </dd></dl>

</div>
</div>
<a id="a2bfcc0100504c8fd429c2c851d53b5f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfcc0100504c8fd429c2c851d53b5f2">&#9670;&nbsp;</a></span>map_to_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> wmtk::Mesh::map_to_root </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps a simplex from this mesh to the root mesh </p>
<p>Cannot be used outside of applications with guaranteed multi-mesh structures</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_simplex</td><td>the simplex being mapped to the parent mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unique root mesh's simplex that is the root to the input one </dd></dl>

</div>
</div>
<a id="a0527755d4723343b29b6d84259ae6625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0527755d4723343b29b6d84259ae6625">&#9670;&nbsp;</a></span>map_to_root_tuple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> wmtk::Mesh::map_to_root_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps a simplex from this mesh to the root mesh </p>
<p>Cannot be used outside of applications with guaranteed multi-mesh structures</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">my_simplex</td><td>the simplex being mapped to the parent mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the unique root mesh's simplex that is the root to the input one, without the dimension encoded </dd></dl>

</div>
</div>
<a id="a90d45551368cb9e55efbfda44d356c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d45551368cb9e55efbfda44d356c09">&#9670;&nbsp;</a></span>map_tuples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; wmtk::Mesh::map_tuples </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &amp;&#160;</td>
          <td class="paramname"><em>other_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1simplex_1_1_simplex.html">Simplex</a> &amp;&#160;</td>
          <td class="paramname"><em>my_simplex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>maps a simplex from this mesh to any other mesh </p>
<p>Generic interface for mapping between two arbitrary meshes in a multi-mesh structure Note that this finds ALL versions of a simplex, potentially crossing over topological features above the pairs of simplices being mapped. For instance, if we map a trimesh seam edge to itself using this interface it will find the edge on the other side of the seam. If more granular mappings are required, consider manually navigating the tree with map_to_parent and map_to_child, which of course requires a more particular understanding on how a simplex is mapped. throws if two meshes are not part of the same multi-mesh structure</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other_mesh</td><td>the mesh a simplex should be mapped to </td></tr>
    <tr><td class="paramname">my_simplex</td><td>the simplex being mapped to the child mesh </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>every simplex that corresponds to this simplex, without the dimension encoded </dd></dl>

</div>
</div>
<a id="ac5778c1f8afef3a2b1b1c33a140b3166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5778c1f8afef3a2b1b1c33a140b3166">&#9670;&nbsp;</a></span>parent_scope()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Functor , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) wmtk::Mesh::parent_scope </td>
          <td>(</td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluate the passed in function inside the parent scope. The parent_scope function can be nested to reach deeper levels in the scope stack. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>The function that is evaluated within the parent scope. </td></tr>
    <tr><td class="paramname">args...</td><td>The other arguments to this function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The return value of f. </dd></dl>

</div>
</div>
<a id="a333e19ee5ddb037313fa7dbdb0e41771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a333e19ee5ddb037313fa7dbdb0e41771">&#9670;&nbsp;</a></span>register_child_mesh()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wmtk::Mesh::register_child_mesh </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classwmtk_1_1_mesh.html">Mesh</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::array&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a>, 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>map_tuples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>register a mesh as the child of this mesh </p>
<p>The parameter map_tuples is a sequence of {A,B} where A is a tuple of this mesh and B is a tuple of the child mesh. The tuple B is assumed to encode a top dimension simplex in the child mesh, and A is any tuple that corresponds to that simplex in the parent mesh</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">child_mesh</td><td>the mesh that will become a child of this mesh </td></tr>
    <tr><td class="paramname">mesh_tuples</td><td>a sequence of corresponding tuples between meshes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9a326d46e931aebe5707255618d4a0b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a326d46e931aebe5707255618d4a0b0">&#9670;&nbsp;</a></span>reserve_attributes_to_fit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wmtk::Mesh::reserve_attributes_to_fit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reserve space for all attributes data types for all dimensional simplices </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">top_d</td><td>the top dimensional simplex </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f0cd5ad21e7d1ce9b132c5cfdc455f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f0cd5ad21e7d1ce9b132c5cfdc455f">&#9670;&nbsp;</a></span>resurrect_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> wmtk::Mesh::resurrect_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ConstAccessor&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>hash_accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>return the same tuple but with updated hash </p>
<p>This function should only be used in operations to create a valid return tuple in a known position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tuple</td><td>tuple with potentially outdated hash </td></tr>
    <tr><td class="paramname">hash_accessor</td><td>hash accessor </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>tuple with updated hash </dd></dl>

</div>
</div>
<a id="a965a8a24158c4aa8580c57ba09f885f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a965a8a24158c4aa8580c57ba09f885f7">&#9670;&nbsp;</a></span>switch_tuple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> wmtk::Mesh::switch_tuple </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PrimitiveType&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>switch the orientation of the <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> of the given dimension </p>
<dl class="section note"><dt>Note</dt><dd>this is not doen in place. Return a new <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> of the switched state</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td></td></tr>
    <tr><td class="paramname">type</td><td>d-0 -&gt; switch vertex d-1 -&gt; switch edge d-2 -&gt; switch face d-3 -&gt; switch tetrahedron </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classwmtk_1_1_tri_mesh.html#a980d7bf51ebd7a8c096e904867bd9a41">wmtk::TriMesh</a>, <a class="el" href="classwmtk_1_1_tet_mesh.html#a4525e2b5565d11fda49e902958dbf4c4">wmtk::TetMesh</a>, <a class="el" href="classwmtk_1_1_point_mesh.html#a66bcea03adca55331c31f915260f6174">wmtk::PointMesh</a>, and <a class="el" href="classwmtk_1_1_edge_mesh.html#a46725851b572b51a356450adc30c14ed">wmtk::EdgeMesh</a>.</p>

</div>
</div>
<a id="a1dfb62b5d5aab1340e03fca5049951bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dfb62b5d5aab1340e03fca5049951bf">&#9670;&nbsp;</a></span>tuple_from_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> wmtk::Mesh::tuple_from_id </td>
          <td>(</td>
          <td class="paramtype">const PrimitiveType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>gid</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>internal function that returns the tuple of requested type, and has the global index cid </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gid</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> </dd></dl>

<p>Implemented in <a class="el" href="classwmtk_1_1_tri_mesh.html#a70db1b74326caedf673701f7afec7513">wmtk::TriMesh</a>, <a class="el" href="classwmtk_1_1_tet_mesh.html#a6d74a26665cd3920afe088826b1baa40">wmtk::TetMesh</a>, <a class="el" href="classwmtk_1_1_point_mesh.html#a9a8e4ead020cda8bbffa7611de19d72e">wmtk::PointMesh</a>, and <a class="el" href="classwmtk_1_1_edge_mesh.html#af237a5c2f89e9ac794b5425ce31b427c">wmtk::EdgeMesh</a>.</p>

</div>
</div>
<a id="a4bcadcbeb0bcbd4a82905620ec4c3a20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bcadcbeb0bcbd4a82905620ec4c3a20">&#9670;&nbsp;</a></span>update_cell_hash() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wmtk::Mesh::update_cell_hash </td>
          <td>(</td>
          <td class="paramtype">const long&#160;</td>
          <td class="paramname"><em>cell_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>hash_accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same as <code>update_cell_hashes</code> but slow because it creates a new accessor </p>
<p>update hash in given cell</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>tuple in which the hash should be updated </td></tr>
    <tr><td class="paramname">hash_accessor</td><td>hash accessor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5372ed754550f3b86f14dd12dd5197c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5372ed754550f3b86f14dd12dd5197c7">&#9670;&nbsp;</a></span>update_cell_hash() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wmtk::Mesh::update_cell_hash </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>hash_accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update hash in given cell </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>tuple in which the hash should be updated </td></tr>
    <tr><td class="paramname">hash_accessor</td><td>hash accessor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a823ea6b42a81227ca35a7aa5ac760cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a823ea6b42a81227ca35a7aa5ac760cea">&#9670;&nbsp;</a></span>update_cell_hashes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wmtk::Mesh::update_cell_hashes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>hash_accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update hashes in given cells </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cells</td><td>vector of tuples in which the hash should be updated </td></tr>
    <tr><td class="paramname">hash_accessor</td><td>hash accessor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afd77a22e8fcbd11e52678e0c589bdde8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd77a22e8fcbd11e52678e0c589bdde8">&#9670;&nbsp;</a></span>update_cell_hashes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wmtk::Mesh::update_cell_hashes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>hash_accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update hashes in given cells </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cells</td><td>vector of tuples in which the hash should be updated </td></tr>
    <tr><td class="paramname">hash_accessor</td><td>hash accessor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1af49f6d60eb21777fbc3e4718930bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af49f6d60eb21777fbc3e4718930bb8">&#9670;&nbsp;</a></span>update_vertex_operation_hashes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wmtk::Mesh::update_vertex_operation_hashes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classwmtk_1_1_tuple.html">Tuple</a> &amp;&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Accessor&lt; long &gt; &amp;&#160;</td>
          <td class="paramname"><em>hash_accessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>wrapper function to update hashes (for parent mesh *this and its child meshes) after vertex operations </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vertex</td><td>operating vertex tuple </td></tr>
    <tr><td class="paramname">hash_accessor</td><td>hash accesor of the parent mesh (*this) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/opt/wmtk-wildmeshing-actions-runner/_work/wildmeshing-toolkit/wildmeshing-toolkit/src/wmtk/<a class="el" href="_mesh_8hpp_source.html">Mesh.hpp</a></li>
<li>/opt/wmtk-wildmeshing-actions-runner/_work/wildmeshing-toolkit/wildmeshing-toolkit/src/wmtk/Mesh.cpp</li>
<li>/opt/wmtk-wildmeshing-actions-runner/_work/wildmeshing-toolkit/wildmeshing-toolkit/src/wmtk/Mesh_attributes.cpp</li>
<li>/opt/wmtk-wildmeshing-actions-runner/_work/wildmeshing-toolkit/wildmeshing-toolkit/src/wmtk/Mesh_construction.cpp</li>
<li>/opt/wmtk-wildmeshing-actions-runner/_work/wildmeshing-toolkit/wildmeshing-toolkit/src/wmtk/Mesh_hash.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
