#include "tetmesh_topology_initialization.h"
#include <algorithm>
#include <fstream>
#include <iostream>
#include <vector>
#include <wmtk/autogen/tet_mesh/autogenerated_tables.hpp>
#include <wmtk/utils/Logger.hpp>

namespace wmtk {

std::tuple<RowVectors6l, RowVectors4l, RowVectors4l, VectorXl, VectorXl, VectorXl>
tetmesh_topology_initialization(Eigen::Ref<const RowVectors4l> T)
{
    RowVectors6l TE;
    RowVectors4l TF;
    RowVectors4l TT;
    VectorXl FT;
    VectorXl ET;
    VectorXl VT;

    // First pass is identifying faces, and filling VT

    // This matrix holds a halfedge like data structure. For each face, it holds the three vertex
    // IDs in lexicographical order, the incident tet ID and its local face ID.
    std::vector<std::vector<int64_t>> TTT;

    const char iv0 = 0; // first vertex ID of a face
    const char iv1 = 1; // second vertex ID of a face
    const char iv2 = 2; // third vertex ID of a face
    const char it = 3; // tet ID
    const char ii = 4; // local face or edge ID


    int64_t vertex_count = T.maxCoeff() + 1;

    // Build a table for finding faces and populate the corresponding
    // topology relations
    {
        TTT.resize(T.rows() * 4);
        for (int64_t t = 0; t < T.rows(); ++t) {
            for (int64_t i = 0; i < 4; ++i) {
                // v1 v2 v3 f ei
                int64_t v0 = T(t, static_cast<int64_t>(autogen::tet_mesh::auto_3d_faces[i][0]));
                int64_t v1 = T(t, static_cast<int64_t>(autogen::tet_mesh::auto_3d_faces[i][1]));
                int64_t v2 = T(t, static_cast<int64_t>(autogen::tet_mesh::auto_3d_faces[i][2]));
                if (v0 > v1) std::swap(v0, v1);
                if (v1 > v2) std::swap(v1, v2);
                if (v0 > v1) std::swap(v0, v1);

                std::vector<int64_t> r(5);
                r[iv0] = v0;
                r[iv1] = v1;
                r[iv2] = v2;
                r[it] = t;
                r[ii] = i;
                TTT[t * 4 + i] = r;
            }
        }
        std::sort(TTT.begin(), TTT.end());

        // std::ofstream file("TTT_F_debug.txt");
        // for (const auto& row : TTT) {
        //     for (const auto& element : row) {
        //         file << element << " ";
        //     }
        //     file << std::endl;
        // }
        // file.close();

        // VT
        VT.resize(vertex_count, 1);
        for (int64_t i = 0; i < T.rows(); ++i) {
            for (int64_t j = 0; j < T.cols(); ++j) {
                VT[T(i, j)] = i;
            }
        }

        // Compute TF, TT, and FT
        TF.resize(T.rows(), 4);
        TT.resize(T.rows(), 4);
        std::vector<int64_t> FT_temp;

        // iterate over TTT to find faces
        // for every entry check if the next is the same, and update the connectivity accordingly

        for (int64_t i = 0; i < TTT.size(); /*increment at the end of the loop*/) {
            FT_temp.push_back(TTT[i][it]);

            int64_t multiplicity = 0;

            for (int j = i; j < TTT.size(); ++j) {
                if ((TTT[i][0] == TTT[j][0]) && (TTT[i][1] == TTT[j][1]) &&
                    (TTT[i][2] == TTT[j][2])) {
                    // edges `i` and `j` are the same
                    ++multiplicity;

                    TT(TTT[j][it], TTT[j][ii]) = -1;
                    TF(TTT[j][it], TTT[j][ii]) = FT_temp.size() - 1;
                } else {
                    break;
                }
            }

            switch (multiplicity) {
            case 1:
                // face is a boundary
                break;
            case 2:
                // connect tets if face is manifold
                TT(TTT[i][it], TTT[i][ii]) = TTT[i + 1][it];
                TT(TTT[i + 1][it], TTT[i + 1][ii]) = TTT[i][it];
                break;
            default:
                // face is non-manifold
                log_and_throw_error(
                    "Non-manifold face: v0 = {}, v1 = {}, v2 = {}. Multiplicity = {}",
                    TTT[i][0],
                    TTT[i][1],
                    TTT[i][2],
                    multiplicity);
                break;
            }

            i += multiplicity; // skip the other entries
        }

        // copy FT
        FT.resize(FT_temp.size());
        for (int64_t i = 0; i < FT_temp.size(); ++i) {
            FT(i) = FT_temp[i];
        }
    }

    // Build a table for finding edges and populate the corresponding
    // topology relations
    {
        TTT.resize(T.rows() * 6);
        for (int64_t t = 0; t < T.rows(); ++t) {
            for (int64_t i = 0; i < 6; ++i) {
                // v1 v2 f ei
                int64_t x = T(t, static_cast<int64_t>(autogen::tet_mesh::auto_3d_edges[i][0]));
                int64_t y = T(t, static_cast<int64_t>(autogen::tet_mesh::auto_3d_edges[i][1]));
                if (x > y) std::swap(x, y);

                std::vector<int64_t> r(5);
                r[iv0] = x;
                r[iv1] = y;
                r[iv2] = 0; // unused
                r[it] = t;
                r[ii] = i;
                TTT[t * 6 + i] = r;
            }
        }
        std::sort(TTT.begin(), TTT.end());

        // std::ofstream file("TTT_E_debug.txt");
        // for (const auto& row : TTT) {
        //     for (const auto& element : row) {
        //         file << element << " ";
        //     }
        //     file << std::endl;
        // }
        // file.close();


        // Compute TE, ET
        TE.resize(T.rows(), 6);
        std::vector<int64_t> ET_temp;


        // iterate over TTT to find edges
        // for every entry check if the next is the same, and update the connectivity accordingly
        for (int64_t i = 0; i < TTT.size(); /*increment at the end of the loop*/) {
            ET_temp.push_back(TTT[i][it]);

            int64_t multiplicity = 0;

            for (int j = i; j < TTT.size(); ++j) {
                if ((TTT[i][0] == TTT[j][0]) && (TTT[i][1] == TTT[j][1])) {
                    // edges `i` and `j` are the same
                    ++multiplicity;

                    TE(TTT[j][it], TTT[j][ii]) = ET_temp.size() - 1;
                } else {
                    break;
                }
            }

            i += multiplicity; // skip the other entries
        }

        // copy ET
        ET.resize(ET_temp.size());
        for (int64_t i = 0; i < ET_temp.size(); ++i) ET(i) = ET_temp[i];
    }

    return {TE, TF, TT, VT, ET, FT};
}

} // namespace wmtk
