#include <catch2/catch_test_macros.hpp>
#include <nlohmann/json.hpp>
#include <wmtk/PointMesh.hpp>
#include <wmtk/Scheduler.hpp>
#include <wmtk/TriMesh.hpp>
#include <wmtk/autogen/tri_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tri_mesh/local_switch_tuple.hpp>
#include <wmtk/invariants/MultiMeshLinkConditionInvariant.hpp>
#include <wmtk/io/MeshReader.hpp>
#include <wmtk/operations/EdgeCollapse.hpp>
#include <wmtk/operations/EdgeSplit.hpp>
#include <wmtk/operations/attribute_new/SplitNewAttributeStrategy.hpp>
#include <wmtk/simplex/closed_star.hpp>
#include <wmtk/simplex/top_dimension_cofaces.hpp>
#include <wmtk/utils/Logger.hpp>
#include <wmtk/utils/mesh_utils.hpp>

#include <polysolve/Utils.hpp>

using json = nlohmann::json;

using namespace wmtk;

const std::filesystem::path data_dir = WMTK_DATA_DIR;

TEST_CASE("Read_only", "[performance][.]")
{
    const std::filesystem::path meshfile =
        data_dir / "adaptive_tessellation_test" / "after_smooth_uv.msh";

    auto mesh_in = wmtk::read_mesh(meshfile, true);
    Mesh& m = *mesh_in;

    auto pos_handle = m.get_attribute_handle<double>("vertices", PrimitiveType::Vertex);
    auto pos_acc = m.create_accessor<double>(pos_handle);

    double sum = 0;

    const auto vertices = m.get_all(PrimitiveType::Vertex);
    for (int i = 0; i < 10000; ++i) {
        for (const Tuple& t : vertices) {
            sum += pos_acc.const_vector_attribute(t)[0];
        }
        for (const Tuple& t : vertices) {
            sum += pos_acc.const_vector_attribute(t)[1];
        }
    }
    std::cout << "sum = " << sum << std::endl;
}

TEST_CASE("accessor_performance", "[accessor][performance][.]")
{
    const std::filesystem::path meshfile = data_dir / "armadillo.msh";

    logger().set_level(spdlog::level::trace);

    auto mesh_in = wmtk::read_mesh(meshfile);
    Mesh& m = *mesh_in;

    auto pos_handle = m.get_attribute_handle<double>("vertices", PrimitiveType::Vertex);
    auto pos_acc = m.create_accessor<double>(pos_handle);

    const size_t n_repetitions = 50000;

    const auto vertices = m.get_all(PrimitiveType::Vertex);

    // create matrix of positions
    Eigen::MatrixXd positions;
    positions.resize(vertices.size(), 3);
    for (size_t i = 0; i < vertices.size(); ++i) {
        positions.row(i) = pos_acc.const_vector_attribute(vertices[i]);
    }

    {
        POLYSOLVE_SCOPED_STOPWATCH("Direct", logger());
        double sum = 0;
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (size_t i = 0; i < vertices.size(); ++i) {
                sum += positions(i, 0);
            }
            for (size_t i = 0; i < vertices.size(); ++i) {
                sum += positions(i, 1);
            }
            for (size_t i = 0; i < vertices.size(); ++i) {
                sum += positions(i, 2);
            }
        }
        std::cout << "sum = " << sum << std::endl;
    }

    PointMesh pm(vertices.size());
    auto pph = mesh_utils::set_matrix_attribute(positions, "vertices", PrimitiveType::Vertex, pm);
    auto pp_acc = pm.create_accessor<double>(pph);
    {
        const auto vv = pm.get_all(PrimitiveType::Vertex);
        POLYSOLVE_SCOPED_STOPWATCH("PointMesh wmtk::attribute::Accessors", logger());
        double sum = 0;
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vv) {
                sum += pp_acc.const_vector_attribute(t)[0];
            }
            for (const Tuple& t : vv) {
                sum += pp_acc.const_vector_attribute(t)[1];
            }
            for (const Tuple& t : vv) {
                sum += pp_acc.const_vector_attribute(t)[2];
            }
        }
        std::cout << "sum = " << sum << std::endl;
    }

    //{
    //    POLYSOLVE_SCOPED_STOPWATCH("TriMesh wmtk::attribute::Accessors", logger());
    //    double sum = 0;
    //    for (size_t i = 0; i < n_repetitions; ++i) {
    //        for (const Tuple& t : vertices) {
    //            sum += pos_acc.const_vector_attribute(t)[0];
    //        }
    //        for (const Tuple& t : vertices) {
    //            sum += pos_acc.const_vector_attribute(t)[1];
    //        }
    //        for (const Tuple& t : vertices) {
    //            sum += pos_acc.const_vector_attribute(t)[2];
    //        }
    //    }
    //    std::cout << "sum = " << sum << std::endl;
    //}
}

TEST_CASE("accessor_write_performance", "[accessor][performance][.]")
{
    const std::filesystem::path meshfile = data_dir / "armadillo.msh";

    logger().set_level(spdlog::level::trace);

    auto mesh_in = wmtk::read_mesh(meshfile);
    Mesh& m = *mesh_in;

    auto pos_handle = m.get_attribute_handle<double>("vertices", PrimitiveType::Vertex);
    auto pos_acc = m.create_accessor<double>(pos_handle);

    const size_t n_repetitions = 1000;

    const auto vertices = m.get_all(PrimitiveType::Vertex);

    // create matrix of positions
    Eigen::MatrixXd positions;
    positions.resize(vertices.size(), 3);
    for (size_t i = 0; i < vertices.size(); ++i) {
        positions.row(i) = pos_acc.const_vector_attribute(vertices[i]);
    }

    {
        POLYSOLVE_SCOPED_STOPWATCH("Direct", logger());
        double sum = 0;
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (size_t i = 0; i < vertices.size(); ++i) {
                positions(i, 0) = sum++;
            }
        }
        std::cout << "sum = " << sum << std::endl;
    }

    PointMesh pm(vertices.size());
    auto pph = mesh_utils::set_matrix_attribute(positions, "vertices", PrimitiveType::Vertex, pm);
    auto pp_acc = pm.create_accessor<double>(pph);
    {
        POLYSOLVE_SCOPED_STOPWATCH("PointMesh wmtk::attribute::Accessors", logger());
        double sum = 0;
        const auto vv = pm.get_all(PrimitiveType::Vertex);
        for (size_t i = 0; i < n_repetitions; ++i) {
            {
                auto scope = pm.create_scope();

                for (const Tuple& t : vv) {
                    pp_acc.vector_attribute(t)[0] = sum++;
                }

                // scope.mark_failed();
            }
        }
        std::cout << "sum = " << sum << std::endl;
    }
}

TEST_CASE("split_with_attributes", "[performance][.]")
{
    using namespace operations;

    const std::filesystem::path meshfile = data_dir / "armadillo.msh";
    const int64_t iterations = 5;

    auto mesh_in = wmtk::read_mesh(meshfile);
    Mesh& m = *mesh_in;

    auto pos_handle = m.get_attribute_handle<double>("vertices", PrimitiveType::Vertex);


    std::vector<attribute::MeshAttributeHandle> pass_through_attributes;
    pass_through_attributes.emplace_back(pos_handle);

    std::string test_name;
    SECTION("pos")
    {
        test_name = "[pos]";
    }
    SECTION("pos_double3")
    {
        test_name = "[pos,d3]";
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr", PrimitiveType::Vertex, 3));
    }
    SECTION("many_doubles")
    {
        test_name = "[pos,d3]";
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr1", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr2", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr3", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr4", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr5", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr6", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr7", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr8", PrimitiveType::Vertex, 3));
        pass_through_attributes.emplace_back(
            m.register_attribute<double>("double_attr9", PrimitiveType::Vertex, 3));
    }

    // split
    auto op_split = std::make_shared<EdgeSplit>(m);

    for (const auto& attr : pass_through_attributes) {
        op_split->set_new_attribute_strategy(attr);
    }


    {
        logger().set_level(spdlog::level::off);
        POLYSOLVE_SCOPED_STOPWATCH(test_name, logger());
        Scheduler scheduler;
        SchedulerStats pass_stats;
        for (long i = 0; i < iterations; ++i) {
            pass_stats += scheduler.run_operation_on_all(*op_split);
        }
        logger().set_level(spdlog::level::trace);
        logger().info("#performed operations : {}", pass_stats.number_of_performed_operations());
        logger().info("#successful operations: {}", pass_stats.number_of_successful_operations());
    }
}

TEST_CASE("collapse_performance", "[performance][.]")
{
    using namespace operations;

    const std::filesystem::path meshfile = data_dir / "armadillo.msh";
    const int64_t iterations = 5;

    auto mesh_in = wmtk::read_mesh(meshfile);
    Mesh& m = *mesh_in;

    auto pos_handle = m.get_attribute_handle<double>("vertices", PrimitiveType::Vertex);


    std::vector<attribute::MeshAttributeHandle> pass_through_attributes;
    pass_through_attributes.emplace_back(pos_handle);

    auto invariant_link_condition = std::make_shared<MultiMeshLinkConditionInvariant>(m);

    //////////////////////////////////////////
    // collapse
    auto op_collapse = std::make_shared<EdgeCollapse>(m);
    op_collapse->add_invariant(invariant_link_condition);
    op_collapse->set_new_attribute_strategy(pos_handle);

    {
        logger().set_level(spdlog::level::off);
        POLYSOLVE_SCOPED_STOPWATCH("Collapse", logger());
        Scheduler scheduler;
        SchedulerStats pass_stats;
        for (long i = 0; i < iterations; ++i) {
            pass_stats += scheduler.run_operation_on_all(*op_collapse);
        }
        logger().set_level(spdlog::level::trace);
        logger().info("#performed operations : {}", pass_stats.number_of_performed_operations());
        logger().info("#successful operations: {}", pass_stats.number_of_successful_operations());
    }
}

TEST_CASE("navigation_performance_tri", "[simplex][performance][.]")
{
    //const std::filesystem::path meshfile = data_dir / "tetwild_fig8_mid.msh"; // 3D
    const std::filesystem::path meshfile = data_dir / "armadillo.msh"; // 2D

    logger().set_level(spdlog::level::trace);

    auto mesh_in = wmtk::read_mesh(meshfile);
    Mesh& m = *mesh_in;

    auto pos_handle = m.get_attribute_handle<double>("vertices", PrimitiveType::Vertex);
    auto pos_acc = m.create_accessor<double>(pos_handle);

    const size_t n_repetitions = 100;

    const auto vertices = m.get_all(PrimitiveType::Vertex);

    logger().info("#operations (#vertices * #reps): {}", n_repetitions * vertices.size());

    size_t counter = 0;
    if (true) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces_tuples", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs =
                    simplex::top_dimension_cofaces_tuples(m, simplex::Simplex::vertex(m, t));
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (true) {
        TriMesh& mesh = static_cast<TriMesh&>(m);

        POLYSOLVE_SCOPED_STOPWATCH("manual navigation", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t_in : vertices) {
                Tuple t = t_in;
                do {
                    counter++;

                    if (!mesh.is_boundary_edge(t)) {
                        t = mesh.switch_tuples(t, {PrimitiveType::Triangle, PrimitiveType::Edge});
                    } else {
                        break;
                    }
                } while (t != t_in);

                if (t == t_in && !mesh.is_boundary_edge(t)) {
                    continue;
                }

                t = mesh.switch_edge(t_in);
                if (mesh.is_boundary_edge(t)) {
                    continue;
                }
                t = mesh.switch_tuples(t, {PrimitiveType::Triangle, PrimitiveType::Edge});
                do {
                    counter++;

                    if (!mesh.is_boundary_edge(t)) {
                        t = mesh.switch_tuples(t, {PrimitiveType::Triangle, PrimitiveType::Edge});
                    } else {
                        break;
                    }
                } while (true);
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (true) {
        TriMesh& mesh = static_cast<TriMesh&>(m);

        auto lexid = [](const Tuple& t) -> int64_t { return 3 * t.local_vid() + t.local_eid(); };

        const auto faces = mesh.get_all(PrimitiveType::Triangle);

        std::vector<bool> is_boundary_edge(faces.size() * 3, false);
        std::vector<std::tuple<int8_t, int8_t, int32_t>> ff(
            faces.size() * 9,
            std::make_tuple(-1, -1, -1));

        {
            for (const Tuple& t_in : faces) {
                Tuple t = t_in;
                do {
                    if (mesh.is_boundary_edge(t)) {
                        is_boundary_edge[3 * t.global_cid() + t.local_eid()] = true;
                    }

                    int64_t id = lexid(t);
                    Tuple t_opp = mesh.switch_face(t);
                    ff[t.global_cid() * 9 + id] =
                        std::make_tuple(t_opp.local_vid(), t_opp.local_eid(), t_opp.global_cid());

                    t = mesh.switch_edge(t);

                    id = lexid(t);
                    t_opp = mesh.switch_face(t);
                    ff[t.global_cid() * 9 + id] =
                        std::make_tuple(t_opp.local_vid(), t_opp.local_eid(), t_opp.global_cid());

                    t = mesh.switch_vertex(t);
                } while (t != t_in);
            }
        }
        {
            auto switch_face_and_edge = [&ff, &lexid](const Tuple& t) {
                const int64_t id = lexid(t);
                auto [v, e, c] = ff[t.global_cid() * 9 + id];
                if (v == (e + 1) % 3) {
                    e = (v + 1) % 3;
                } else {
                    e = (e + 1) % 3;
                }
                return Tuple(v, e, t.local_fid(), c);
            };

            POLYSOLVE_SCOPED_STOPWATCH("chache vertex neighbors", logger());
            for (size_t i = 0; i < n_repetitions; ++i) {
                for (const Tuple& t_in : vertices) {
                    Tuple t = t_in;
                    do {
                        counter++;

                        if (!is_boundary_edge[3 * t.global_cid() + t.local_eid()]) {
                            t = switch_face_and_edge(t);
                        } else {
                            break;
                        }
                    } while (t != t_in);

                    if (t == t_in && !is_boundary_edge[3 * t.global_cid() + t.local_eid()]) {
                        continue;
                    }

                    t = autogen::tri_mesh::local_switch_tuple(t, PrimitiveType::Edge);
                    if (is_boundary_edge[3 * t.global_cid() + t.local_eid()]) {
                        continue;
                    }

                    t = switch_face_and_edge(t);

                    do {
                        counter++;

                        if (!is_boundary_edge[3 * t.global_cid() + t.local_eid()]) {
                            t = switch_face_and_edge(t);
                        } else {
                            break;
                        }
                    } while (true);
                }
            }
            logger().info("sum = {}", counter);
        }
    }

    counter = 0;
    if (true) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces_tuples with pre-reserve", logger());
        std::vector<Tuple> n;
        n.reserve(100);
        for (size_t i = 0; i < n_repetitions; ++i) {
            n.clear();
            for (const Tuple& t : vertices) {
                simplex::top_dimension_cofaces_tuples(m, simplex::Simplex::vertex(m, t), n);
                counter += n.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (false) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces (no sort)", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs =
                    simplex::top_dimension_cofaces(m, simplex::Simplex::vertex(m, t), false);
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (false) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces (sort)", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs =
                    simplex::top_dimension_cofaces(m, simplex::Simplex::vertex(m, t), true);
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (false) {
        POLYSOLVE_SCOPED_STOPWATCH("closed_star (no sort)", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs = simplex::closed_star(m, simplex::Simplex::vertex(m, t), false);
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (false) {
        POLYSOLVE_SCOPED_STOPWATCH("closed_star (sort)", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs = simplex::closed_star(m, simplex::Simplex::vertex(m, t), true);
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }
}

TEST_CASE("navigation_performance_tet", "[simplex][performance][.]")
{
    const std::filesystem::path meshfile = data_dir / "tetwild_fig8_mid.msh"; // 3D

    logger().set_level(spdlog::level::trace);

    auto mesh_in = wmtk::read_mesh(meshfile);
    Mesh& m = *mesh_in;

    auto pos_handle = m.get_attribute_handle<double>("vertices", PrimitiveType::Vertex);
    auto pos_acc = m.create_accessor<double>(pos_handle);

    const size_t n_repetitions = 20;

    const auto vertices = m.get_all(PrimitiveType::Vertex);

    logger().info("#operations (#vertices * #reps): {}", n_repetitions * vertices.size());

    size_t counter = 0;
    if (true) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces_tuples", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs =
                    simplex::top_dimension_cofaces_tuples(m, simplex::Simplex::vertex(m, t));
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (true) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces_tuples with pre-reserve", logger());
        std::vector<Tuple> n;
        n.reserve(100);
        for (size_t i = 0; i < n_repetitions; ++i) {
            n.clear();
            for (const Tuple& t : vertices) {
                simplex::top_dimension_cofaces_tuples(m, simplex::Simplex::vertex(m, t), n);
                counter += n.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (false) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces (no sort)", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs =
                    simplex::top_dimension_cofaces(m, simplex::Simplex::vertex(m, t), false);
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }

    counter = 0;
    if (false) {
        POLYSOLVE_SCOPED_STOPWATCH("top_dimension_cofaces (sort)", logger());
        for (size_t i = 0; i < n_repetitions; ++i) {
            for (const Tuple& t : vertices) {
                const auto neighs =
                    simplex::top_dimension_cofaces(m, simplex::Simplex::vertex(m, t), true);
                counter += neighs.size();
            }
        }
        logger().info("sum = {}", counter);
    }
}
