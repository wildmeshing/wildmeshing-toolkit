#include "TetMesh.hpp"


#include <wmtk/utils/tetmesh_topology_initialization.h>
#include <wmtk/SimplicialComplex.hpp>
#include <wmtk/TetMeshOperationExecutor.hpp>
#include <wmtk/autogen/tet_mesh/autogenerated_tables.hpp>
#include <wmtk/autogen/tet_mesh/is_ccw.hpp>
#include <wmtk/autogen/tet_mesh/local_switch_tuple.hpp>
#include <wmtk/simplex/cofaces_single_dimension.hpp>
#include <wmtk/utils/Logger.hpp>

namespace wmtk {

using namespace autogen;

TetMesh::TetMesh()
    : Mesh(3)
    , m_vt_handle(register_attribute_nomesh<long>("m_vt", PrimitiveType::Vertex, 1))
    , m_et_handle(register_attribute_nomesh<long>("m_et", PrimitiveType::Edge, 1))
    , m_ft_handle(register_attribute_nomesh<long>("m_ft", PrimitiveType::Face, 1))
    , m_tv_handle(register_attribute_nomesh<long>("m_tv", PrimitiveType::Tetrahedron, 4))
    , m_te_handle(register_attribute_nomesh<long>("m_te", PrimitiveType::Tetrahedron, 6))
    , m_tf_handle(register_attribute_nomesh<long>("m_tf", PrimitiveType::Tetrahedron, 4))
    , m_tt_handle(register_attribute_nomesh<long>("m_tt", PrimitiveType::Tetrahedron, 4))
{}

TetMesh::TetMesh(const TetMesh& o) = default;
TetMesh::TetMesh(TetMesh&& o) = default;
TetMesh& TetMesh::operator=(const TetMesh& o) = default;
TetMesh& TetMesh::operator=(TetMesh&& o) = default;


void TetMesh::initialize(
    Eigen::Ref<const RowVectors4l> TV,
    Eigen::Ref<const RowVectors6l> TE,
    Eigen::Ref<const RowVectors4l> TF,
    Eigen::Ref<const RowVectors4l> TT,
    Eigen::Ref<const VectorXl> VT,
    Eigen::Ref<const VectorXl> ET,
    Eigen::Ref<const VectorXl> FT)

{
    // reserve memory for attributes

    std::vector<long> cap{
        static_cast<long>(VT.rows()),
        static_cast<long>(ET.rows()),
        static_cast<long>(FT.rows()),
        static_cast<long>(TT.rows())};
    set_capacities(cap);

    // get Accessors for topology
    Accessor<long> vt_accessor = create_accessor<long>(m_vt_handle);
    Accessor<long> et_accessor = create_accessor<long>(m_et_handle);
    Accessor<long> ft_accessor = create_accessor<long>(m_ft_handle);

    Accessor<long> tv_accessor = create_accessor<long>(m_tv_handle);
    Accessor<long> te_accessor = create_accessor<long>(m_te_handle);
    Accessor<long> tf_accessor = create_accessor<long>(m_tf_handle);
    Accessor<long> tt_accessor = create_accessor<long>(m_tt_handle);

    Accessor<char> v_flag_accessor = get_flag_accessor(PrimitiveType::Vertex);
    Accessor<char> e_flag_accessor = get_flag_accessor(PrimitiveType::Edge);
    Accessor<char> f_flag_accessor = get_flag_accessor(PrimitiveType::Face);
    Accessor<char> t_flag_accessor = get_flag_accessor(PrimitiveType::Tetrahedron);

    // iterate over the matrices and fill attributes
    for (long i = 0; i < capacity(PrimitiveType::Tetrahedron); ++i) {
        tv_accessor.index_access().vector_attribute(i) = TV.row(i).transpose();
        te_accessor.index_access().vector_attribute(i) = TE.row(i).transpose();
        tf_accessor.index_access().vector_attribute(i) = TF.row(i).transpose();
        tt_accessor.index_access().vector_attribute(i) = TT.row(i).transpose();
        t_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
    // m_vt
    for (long i = 0; i < capacity(PrimitiveType::Vertex); ++i) {
        vt_accessor.index_access().scalar_attribute(i) = VT(i);
        v_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
    // m_et
    for (long i = 0; i < capacity(PrimitiveType::Edge); ++i) {
        et_accessor.index_access().scalar_attribute(i) = ET(i);
        e_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
    // m_ft
    for (long i = 0; i < capacity(PrimitiveType::Face); ++i) {
        ft_accessor.index_access().scalar_attribute(i) = FT(i);
        f_flag_accessor.index_access().scalar_attribute(i) |= 0x1;
    }
}


void TetMesh::initialize(Eigen::Ref<const RowVectors4l> T)
{
    auto [TE, TF, TT, VT, ET, FT] = tetmesh_topology_initialization(T);
    initialize(T, TE, TF, TT, VT, ET, FT);
}

long TetMesh::_debug_id(const Tuple& tuple, PrimitiveType type) const
{
    // do not remove this warning!
    // wmtk::logger().warn("This function must only be used for debugging!!");
    return id(tuple, type);
}

Tuple TetMesh::vertex_tuple_from_id(long id) const
{
    ConstAccessor<long> vt_accessor = create_accessor<long>(m_vt_handle);
    long t = vt_accessor.index_access().scalar_attribute(id);
    ConstAccessor<long> tv_accessor = create_accessor<long>(m_tv_handle);
    auto tv = tv_accessor.index_access().vector_attribute(t);
    long lvid = -1;

    for (long i = 0; i < 4; ++i) {
        if (tv(i) == id) {
            lvid = i;
            break;
        }
    }

    const auto [nlvid, leid, lfid] = autogen::tet_mesh::auto_3d_table_complete_vertex[lvid];
    assert(lvid == nlvid);

    if (lvid < 0 || leid < 0 || lfid < 0) throw std::runtime_error("vertex_tuple_from_id failed");

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple v_tuple = Tuple(lvid, leid, lfid, t, get_cell_hash(t, hash_accessor));
    assert(is_ccw(v_tuple));
    assert(is_valid(v_tuple, hash_accessor));
    return v_tuple;
}

Tuple TetMesh::edge_tuple_from_id(long id) const
{
    ConstAccessor<long> et_accessor = create_accessor<long>(m_et_handle);
    long t = et_accessor.index_access().scalar_attribute(id);
    ConstAccessor<long> te_accessor = create_accessor<long>(m_te_handle);
    auto te = te_accessor.index_access().vector_attribute(t);

    long leid = -1;

    for (long i = 0; i < 6; ++i) {
        if (te(i) == id) {
            leid = i;
            break;
        }
    }
    const auto [lvid, nleid, lfid] = autogen::tet_mesh::auto_3d_table_complete_edge[leid];
    assert(leid == nleid);


    if (lvid < 0 || leid < 0 || lfid < 0) throw std::runtime_error("edge_tuple_from_id failed");

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple e_tuple = Tuple(lvid, leid, lfid, t, get_cell_hash(t, hash_accessor));
    assert(is_ccw(e_tuple));
    assert(is_valid(e_tuple, hash_accessor));
    return e_tuple;
}

Tuple TetMesh::face_tuple_from_id(long id) const
{
    ConstAccessor<long> ft_accessor = create_accessor<long>(m_ft_handle);
    long t = ft_accessor.index_access().scalar_attribute(id);
    ConstAccessor<long> tf_accessor = create_accessor<long>(m_tf_handle);
    auto tf = tf_accessor.index_access().vector_attribute(t);

    long lfid = -1;

    for (long i = 0; i < 4; ++i) {
        if (tf(i) == id) {
            lfid = i;
            break;
        }
    }

    const auto [lvid, leid, nlfid] = autogen::tet_mesh::auto_3d_table_complete_face[lfid];
    assert(lfid == nlfid);

    if (lvid < 0 || leid < 0 || lfid < 0) throw std::runtime_error("face_tuple_from_id failed");

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple f_tuple = Tuple(lvid, leid, lfid, t, get_cell_hash(t, hash_accessor));
    assert(is_ccw(f_tuple));
    assert(is_valid(f_tuple, hash_accessor));
    return f_tuple;
}

Tuple TetMesh::tet_tuple_from_id(long id) const
{
    const long lvid = 0;
    const auto [nlvid, leid, lfid] = autogen::tet_mesh::auto_3d_table_complete_vertex[lvid];
    assert(lvid == nlvid);

    ConstAccessor<long> hash_accessor = get_const_cell_hash_accessor();

    Tuple t_tuple = Tuple(lvid, leid, lfid, id, get_cell_hash(id, hash_accessor));
    assert(is_ccw(t_tuple));
    assert(is_valid(t_tuple, hash_accessor));
    return t_tuple;
}

Tuple TetMesh::tuple_from_id(const PrimitiveType type, const long gid) const
{
    switch (type) {
    case PrimitiveType::Vertex: {
        return vertex_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Edge: {
        return edge_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Face: {
        return face_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::Tetrahedron: {
        return tet_tuple_from_id(gid);
        break;
    }
    case PrimitiveType::HalfEdge:
    default: throw std::runtime_error("Invalid primitive type");
    }
}

auto TetMesh::split_edge(const Tuple& t, Accessor<long>& hash_accessor)
    -> operations::tet_mesh::EdgeOperationData
{
    // prototype
    // Executor exec;
    // exec.populate_ears()
    // exec.populate_faces();
    // exec.run_split();

    TetMeshOperationExecutor executor(*this, t, hash_accessor);
    executor.split_edge();
    return executor;
}

auto TetMesh::collapse_edge(const Tuple& t, Accessor<long>& hash_accessor)
    -> operations::tet_mesh::EdgeOperationData
{
    TetMeshOperationExecutor executor(*this, t, hash_accessor);
    executor.collapse_edge();
    return executor;
}

long TetMesh::id(const Tuple& tuple, PrimitiveType type) const
{
    switch (type) {
    case PrimitiveType::Vertex: {
        ConstAccessor<long> tv_accessor = create_accessor<long>(m_tv_handle);
        auto tv = tv_accessor.vector_attribute(tuple);
        return tv(tuple.m_local_vid);
        break;
    }
    case PrimitiveType::Edge: {
        ConstAccessor<long> te_accessor = create_accessor<long>(m_te_handle);
        auto te = te_accessor.vector_attribute(tuple);
        return te(tuple.m_local_eid);
        break;
    }
    case PrimitiveType::Face: {
        ConstAccessor<long> tf_accessor = create_accessor<long>(m_tf_handle);
        auto tf = tf_accessor.vector_attribute(tuple);
        return tf(tuple.m_local_fid);
        break;
    }
    case PrimitiveType::Tetrahedron: {
        return tuple.m_global_cid;
        break;
    }
    case PrimitiveType::HalfEdge:
    default: throw std::runtime_error("Tuple id: Invalid primitive type");
    }
}

Tuple TetMesh::switch_tuple(const Tuple& tuple, PrimitiveType type) const
{
    assert(is_valid_slow(tuple));
    switch (type) {
    // bool ccw = is_ccw(tuple);
    case PrimitiveType::Tetrahedron: {
        assert(!is_boundary_face(tuple));
        // need test
        const long gvid = id(tuple, PrimitiveType::Vertex);
        const long geid = id(tuple, PrimitiveType::Edge);
        const long gfid = id(tuple, PrimitiveType::Face);

        ConstAccessor<long> tt_accessor = create_const_accessor<long>(m_tt_handle);
        auto tt = tt_accessor.vector_attribute(tuple);

        long gcid_new = tt(tuple.m_local_fid);

        /*handle exception here*/
        assert(gcid_new != -1);
        // check if is_boundary allows removing this exception in 3d cases
        // if (gcid_new == -1) {
        //     return Tuple(-1, -1, -1, -1, -1);
        // }
        /*handle exception end*/

        long lvid_new = -1, leid_new = -1, lfid_new = -1;

        ConstAccessor<long> tv_accessor = create_const_accessor<long>(m_tv_handle);
        auto tv = tv_accessor.index_access().vector_attribute(gcid_new);

        ConstAccessor<long> te_accessor = create_const_accessor<long>(m_te_handle);
        auto te = te_accessor.index_access().vector_attribute(gcid_new);

        ConstAccessor<long> tf_accessor = create_const_accessor<long>(m_tf_handle);
        auto tf = tf_accessor.index_access().vector_attribute(gcid_new);

        for (long i = 0; i < 4; ++i) {
            if (tv(i) == gvid) {
                lvid_new = i;
            }
            if (tf(i) == gfid) {
                lfid_new = i;
            }
        }

        for (long i = 0; i < 6; ++i) {
            if (te(i) == geid) {
                leid_new = i;
                break; // check if the break is correct
            }
        }

        assert(lvid_new != -1);
        assert(leid_new != -1);
        assert(lfid_new != -1);

        const Tuple res(lvid_new, leid_new, lfid_new, gcid_new, get_cell_hash_slow(gcid_new));
        assert(is_valid_slow(res));
        return res;
    }
    case PrimitiveType::Vertex:
    case PrimitiveType::Edge:
    case PrimitiveType::Face:
    default: return autogen::tet_mesh::local_switch_tuple(tuple, type);
    case PrimitiveType::HalfEdge: throw std::runtime_error("Tuple id: Invalid primitive type");
    }
}

bool TetMesh::is_ccw(const Tuple& tuple) const
{
    assert(is_valid_slow(tuple));
    return autogen::tet_mesh::is_ccw(tuple);
}

bool TetMesh::is_valid(const Tuple& tuple, ConstAccessor<long>& hash_accessor) const
{
    if (tuple.is_null()) return false;
    const bool is_connectivity_valid = tuple.m_local_vid >= 0 && tuple.m_local_eid >= 0 &&
                                       tuple.m_local_fid >= 0 && tuple.m_global_cid >= 0 &&
                                       autogen::tet_mesh::tuple_is_valid_for_ccw(tuple);

    if (!is_connectivity_valid) {
        return false;
    }

    return Mesh::is_hash_valid(tuple, hash_accessor);
}

bool TetMesh::is_boundary(const Tuple& tuple, PrimitiveType pt) const
{
    switch (pt) {
    case PrimitiveType::Vertex: return is_boundary_vertex(tuple);
    case PrimitiveType::Edge: return is_boundary_edge(tuple);
    case PrimitiveType::Face: return is_boundary_face(tuple);
    case PrimitiveType::Tetrahedron:
    case PrimitiveType::HalfEdge:
    default: break;
    }
    throw std::runtime_error(
        "tried to compute hte boundary of an edge mesh for an invalid simplex dimension");
    return false;
}


bool TetMesh::is_boundary_face(const Tuple& tuple) const
{
    ConstAccessor<long> tt_accessor = create_accessor<long>(m_tt_handle);
    return tt_accessor.vector_attribute(tuple)(tuple.m_local_fid) < 0;
}

bool TetMesh::is_boundary_edge(const Tuple& edge) const
{
    for (const Tuple& f : simplex::cofaces_single_dimension_tuples(
             *this,
             Simplex::edge(edge),
             PrimitiveType::Face)) {
        if (is_boundary_face(f)) {
            return true;
        }
    }
    return false;
}
bool TetMesh::is_boundary_vertex(const Tuple& vertex) const
{
    // go through all faces and check if they are boundary
    const SimplicialComplex neigh = SimplicialComplex::open_star(*this, Simplex::vertex(vertex));
    for (const Simplex& s : neigh.get_faces()) {
        if (is_boundary(s.tuple())) {
            return true;
        }
    }

    return false;
}

bool TetMesh::is_connectivity_valid() const
{
    // get Accessors for topology
    ConstAccessor<long> tv_accessor = create_const_accessor<long>(m_tv_handle);
    ConstAccessor<long> te_accessor = create_const_accessor<long>(m_te_handle);
    ConstAccessor<long> tf_accessor = create_const_accessor<long>(m_tf_handle);
    ConstAccessor<long> tt_accessor = create_const_accessor<long>(m_tt_handle);
    ConstAccessor<long> vt_accessor = create_const_accessor<long>(m_vt_handle);
    ConstAccessor<long> et_accessor = create_const_accessor<long>(m_et_handle);
    ConstAccessor<long> ft_accessor = create_const_accessor<long>(m_ft_handle);
    ConstAccessor<char> v_flag_accessor = get_flag_accessor(PrimitiveType::Vertex);
    ConstAccessor<char> e_flag_accessor = get_flag_accessor(PrimitiveType::Edge);
    ConstAccessor<char> f_flag_accessor = get_flag_accessor(PrimitiveType::Face);
    ConstAccessor<char> t_flag_accessor = get_flag_accessor(PrimitiveType::Tetrahedron);

    // VT and TV
    for (long i = 0; i < capacity(PrimitiveType::Vertex); ++i) {
        if (v_flag_accessor.index_access().const_scalar_attribute(i) == 0) {
            wmtk::logger().debug("Vertex {} is deleted", i);
            continue;
        }
        int cnt = 0;
        for (int j = 0; j < 4; ++j) {
            if (tv_accessor.index_access().const_vector_attribute(
                    vt_accessor.index_access().const_scalar_attribute(i))[j] == i) {
                cnt++;
            }
        }
        if (cnt != 1) {
            wmtk::logger().info("fail VT and TV");
            return false;
        }
    }

    // ET and TE
    for (long i = 0; i < capacity(PrimitiveType::Edge); ++i) {
        if (e_flag_accessor.index_access().const_scalar_attribute(i) == 0) {
            wmtk::logger().debug("Edge {} is deleted", i);
            continue;
        }
        int cnt = 0;
        for (int j = 0; j < 6; ++j) {
            if (te_accessor.index_access().const_vector_attribute(
                    et_accessor.index_access().const_scalar_attribute(i))[j] == i) {
                cnt++;
            }
        }
        if (cnt != 1) {
            wmtk::logger().info("fail ET and TE");
            return false;
        }
    }

    // FT and TF
    for (long i = 0; i < capacity(PrimitiveType::Face); ++i) {
        if (f_flag_accessor.index_access().const_scalar_attribute(i) == 0) {
            wmtk::logger().debug("Face {} is deleted", i);
            continue;
        }
        int cnt = 0;
        for (int j = 0; j < 4; ++j) {
            if (tf_accessor.index_access().const_vector_attribute(
                    ft_accessor.index_access().const_scalar_attribute(i))[j] == i) {
                cnt++;
            }
        }
        if (cnt != 1) {
            wmtk::logger().info("fail FT and TF");
            return false;
        }
    }

    // TF and TT
    for (long i = 0; i < capacity(PrimitiveType::Tetrahedron); ++i) {
        if (t_flag_accessor.index_access().const_scalar_attribute(i) == 0) {
            wmtk::logger().debug("Tet {} is deleted", i);
            continue;
        }

        for (int j = 0; j < 4; ++j) {
            long nb = tt_accessor.index_access().const_vector_attribute(i)(j);
            if (nb == -1) {
                if (ft_accessor.index_access().const_scalar_attribute(
                        tf_accessor.index_access().const_vector_attribute(i)(j)) != i) {
                    wmtk::logger().info("fail TF and TT 1");
                    return false;
                }
                continue;
            }

            int cnt = 0;
            int id_in_nb;
            for (int k = 0; k < 4; ++k) {
                if (tt_accessor.index_access().const_vector_attribute(nb)(k) == i) {
                    cnt++;
                    id_in_nb = k;
                }
            }
            if (cnt != 1) {
                wmtk::logger().info("fail TF and TT 2");
                return false;
            }

            if (tf_accessor.index_access().const_vector_attribute(i)(j) !=
                tf_accessor.index_access().const_vector_attribute(nb)(id_in_nb)) {
                wmtk::logger().info("fail TF and TT 3");
                return false;
            }
        }
    }

    return true;
}

std::vector<std::vector<TypedAttributeHandle<long>>> TetMesh::connectivity_attributes() const
{
    std::vector<std::vector<TypedAttributeHandle<long>>> handles(4);

    handles[0].push_back(m_tv_handle);
    handles[1].push_back(m_te_handle);
    handles[2].push_back(m_tf_handle);

    handles[3].push_back(m_tt_handle);
    handles[3].push_back(m_vt_handle);
    handles[3].push_back(m_et_handle);
    handles[3].push_back(m_ft_handle);

    return handles;
}


} // namespace wmtk
