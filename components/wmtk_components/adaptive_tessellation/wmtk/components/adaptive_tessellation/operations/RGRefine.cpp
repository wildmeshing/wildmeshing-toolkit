#include "RGRefine.hpp"
#include <wmtk/Mesh.hpp>
#include <wmtk/attribute/AttributeScopeStack.hpp>


namespace wmtk::operations::composite {

RGRefine::RGRefine(Mesh& m, const attribute::MeshAttributeHandle& edge_length_handle)
    : Operation(m)
    , m_split(m)
    , m_second_split(m)
    , m_swap(m)
    , m_edge_length_handle(edge_length_handle)
{}

std::vector<simplex::Simplex> RGRefine::execute(const simplex::Simplex& simplex)
{
    // check if the edge is the longest edge of the other triangle
    // if it is not find which edge is the longest, and set the flag for after split1 navigation
    bool switch_edge_flag = false;
    bool switch_vertex_edge_flag = false;
    const attribute::Accessor<double> edge_length_accessor =
        mesh().create_const_accessor(m_edge_length_handle.as<double>());
    double current_length = edge_length_accessor.const_scalar_attribute(simplex.tuple());
    // decide which edge is the longest edge in the other face
    if (!mesh().is_boundary(simplex)) {
        auto other_face = mesh().switch_tuple(simplex.tuple(), PrimitiveType::Triangle);
        double switch_edge_length = edge_length_accessor.const_scalar_attribute(
            mesh().switch_tuple(other_face, PrimitiveType::Edge));
        double switch_vertex_edge_length = edge_length_accessor.const_scalar_attribute(
            mesh().switch_tuples(other_face, {PrimitiveType::Vertex, PrimitiveType::Edge}));
        if ((switch_edge_length > current_length) || (switch_vertex_edge_length > current_length)) {
            if (switch_edge_length > switch_vertex_edge_length) {
                switch_edge_flag = true;
            } else {
                switch_vertex_edge_flag = true;
            }
        }
    }

    // | \ 
    // |  \ 
    // |a  \b
    // |    \ 
    // |\    \ 
    // |  \   \ 
    // |    \  \ 
    // |     >  \ 
    //  ---------

    // first split: this is the normal split of the target edge
    // | \ 
    // | | \ 
    // |a|  \b
    // |  \  \  
    // |\  \  \ 
    // |  \ X  \ 
    // |   / \  \ 
    // |  /   \  \ 
    // | /     >  \  
    //  ----------
    auto first_split_return = m_split(simplex);
    if (first_split_return.empty()) return {};
    assert(first_split_return.size() == 1);

    if (!(switch_edge_flag || switch_vertex_edge_flag)) {
        return first_split_return;
    }

    const Tuple first_split_output_other_face =
        mesh().switch_tuple(first_split_return.front().tuple(), PrimitiveType::Triangle);
    Tuple second_split_input;
    if (switch_edge_flag) {
        // a is the longest edge of the other face
        second_split_input = mesh().switch_tuples(
            first_split_output_other_face,
            {PrimitiveType::Edge,
             PrimitiveType::Triangle,
             PrimitiveType::Vertex,
             PrimitiveType::Edge});

    } else {
        assert(switch_vertex_edge_flag);
        // b is the longest edge of the other face
        second_split_input = mesh().switch_tuples(
            first_split_output_other_face,
            {PrimitiveType::Vertex, PrimitiveType::Edge});
    }

    auto scope = mesh().create_scope();
    // second split: if the split edge of one of the triangle is not the longest edge, then
    // split the longest edge of that triangle
    // | \ 
    // | | \ 
    // | |  <
    // | |   \ 
    // |  \   \  
    // |\  |   x
    // |  \ X_/ \ 
    // |   /\    \ 
    // |  /   \   \ 
    // | /     \   \  
    //  ----------
    auto second_split_return =
        m_second_split(simplex::Simplex(PrimitiveType::Edge, second_split_input));
    if (second_split_return.empty()) {
        scope.mark_failed();
        return first_split_return;
    }

    const Tuple swap_input = mesh().switch_tuples(
        second_split_return.front().tuple(),
        {PrimitiveType::Vertex, PrimitiveType::Edge});
    // | \ 
    // | | \ 
    // | |  |
    // | |   \ 
    // |  \   \  
    // |\  \>  x
    // |  \ X_/ \ 
    // |   /\    \ 
    // |  /   \   \ 
    // | /     \   \  
    //  ----------
    // swap: if the second split succeeded, swap the new edge generated by the first split in
    // the second split triangle
    // | \ 
    // |   \ 
    // |    \ 
    // |     \ 
    // |______x
    // |\      |\ 
    // |  \ X /  \ 
    // |   /\     \ 
    // |  /   \    \ 
    // | /      \   \  
    //  ----------
    auto swap_return = m_swap(simplex::Simplex(PrimitiveType::Edge, swap_input));
    if (swap_return.empty()) {
        scope.mark_failed();
        return first_split_return;
    }
    assert(swap_return.size() == 1);
    return swap_return;
}
std::vector<simplex::Simplex> RGRefine::unmodified_primitives(const simplex::Simplex& simplex) const
{
    return {simplex};
}
} // namespace wmtk::operations::composite